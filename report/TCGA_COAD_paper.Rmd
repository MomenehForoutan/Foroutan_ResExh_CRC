---
title: 'Survival and mutation analyses of the TCGA COAD data based on the Res and Exh scores'
author: 
  - name: 'Momeneh (Sepideh) Foroutan and Ramyar Molania'
    affiliation: 'Huntington Cancer Immunotherapy Lab'
    url: https://www.monash.edu/discovery-institute/huntington-lab
date: '12-06-2020'
output:
  rmdformats::readthedown:
    fig_width: 12
    fig_height: 6
    gallery: TRUE
    highlight: tango
    lightbox: TRUE
    self_contained: TRUE
    thumbnails: FALSE
    number_sections: TRUE	
    toc_depth: 4
    use_bookdown: TRUE
    code_folding: hide
  html_document2:
    df_print: paged
params:
  update_date: !r paste("Last updated on:", Sys.Date() )
editor_options: 
  chunk_output_type: inline
---
`r params$update_date`

<style>
body {
text-align: justify}
</style>

# Set up and overview
In this document, we read the corrected TCGA COAD data (using the RUV-III method), perform CMS clustering, and visualise the associations between Res_bulk and Exh_bulk scores and different sample annotations. We then perform survival analysis to examine the association of the scores with survival outcomes, and finish the analysis by performing mutation analysis to find genes whose mutations are predictive of Res or Exh in cancer samples.
```{r file set up, echo=F, results=F, message=F, warning=F}
mainDir <- getwd()
outPath <- "../output/TCGA/"
figPath <- "../figure/TCGA/"
dataPath <- "../data/"
scriptPath <- "../script/"

## to read gene length data
tcgaPath <-  "../data/TCGA/"

ifelse(!dir.exists(file.path(mainDir, outPath)), dir.create(file.path(mainDir, outPath)), FALSE)
ifelse(!dir.exists(file.path(mainDir, figPath)), dir.create(file.path(mainDir, figPath)), FALSE)
ifelse(!dir.exists(file.path(mainDir, dataPath)), dir.create(file.path(mainDir, dataPath)), FALSE)
ifelse(!dir.exists(file.path(mainDir, scriptPath)), dir.create(file.path(mainDir, scriptPath)), FALSE)

# library(ggplot2)
library(tidyverse)
library(RColorBrewer)
library(ggbeeswarm)
library(SingleCellExperiment)
library(Seurat)

options(digits = 3)

equal_breaks <- function(n = nBreak, s = scalingFactor, ...){
  function(x){
    # rescaling
    d <- s * diff(range(x)) / (1+2*s)
    round( seq(min(x)+d, max(x)-d, length=n), 2)
  }
}

nBreak = 3
scalingFactor = 0.05

textSize <- 1.2

currentTheme <- theme_bw() +
  theme(
    # panel.background = element_blank()
    axis.title = element_text(size = rel(textSize)),
    axis.text = element_text(angle = 0, size = rel(textSize)),
    # strip.background = element_rect(colour = "#f0f0f0", fill = "#f0f0f0"),
    strip.text = element_text(size = rel(textSize)),
    axis.line = element_line(colour = "black", size = 0.5),
    legend.position = 'top',
    legend.title = element_text(size = rel(textSize), face = "italic"),
    legend.text = element_text(size = rel(textSize)),
    legend.key.size = unit(1, 'lines'),
    ## increase the line space
    plot.title = element_text(
      face = "plain",
      size = rel(textSize),
      hjust = 0.5
    )
  )

cols <-  c(
  brewer.pal(8, "Dark2")[-5],
  brewer.pal(10, "Paired"),
  brewer.pal(12, "Set3"),
  brewer.pal(9, "Blues")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "Oranges")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "Greens")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "Purples")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "Reds")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "Greys")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "BuGn")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "PuRd")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "BuPu")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "YlGn")[c(8, 3, 7, 4, 6, 9, 5)])

# source(paste0(FreqScriptPath, "analysis/calcFiltFPKM_TCGA.R"))

source(paste0(scriptPath, "coxph_analysis.R"))
source(paste0(scriptPath,"survival_plot.R"))
```

## Read signatures
We read Res and Exh signatures that we obtained and focus on the genes that are not highly expressed in cancer cells (those that passed the bulk cancer threshold). Additionally, we defined two other types of signatures for eacj of the Exh and Res signatures: All_Res[Exh]_Bulk and CD8NK_Res[Exh]_Bulk by merging all Res[Exh]_Bulk signature genes and by merging only the CD8_Res[Exh]_Bulk and NK_Res[Exh]_Bulk. 
We also read several cancer related signatures as well as a few other immune related signatures collected from the literature as well as MSigDB. Here are the list of the signatures that we used in this document.
```{r}
source(paste0(scriptPath, "ReadSignaturesTum_paper.R"))
names(AllSigsCollection)
```

# Corrected TCGA
We have made an annotation file for the TCGA COAD by combining several annotation data from different sources to include as much info as possible for the samples; these include the [survival data from GDC](https://gdc.cancer.gov/about-data/publications/pancanatlas), the annotation file for the COAD downloaded using the TCGAbiolink package, as well as several columns associated with batch information.

We have also corrected the TCGA COAD data using the RUV-III method as suggested by [Molania et al](https://academic.oup.com/nar/article/47/12/6073/5494770?login=true). Here we read the data and annotation, and subset to the common samples.
```{r}
annot_merged <- readRDS(paste0(tcgaPath, "Annotation_COAD_Merged_InclNormal.RDS"))
currentAnnot_ruv <- annot_merged
```

```{r}
ruvTCGA <- readRDS(paste0(tcgaPath, "DontPush/TCGA_COAD_RUVadjusted_k19_PrpsPerPlateMsiCmsNormalNsample3.rds"))
 
## 479 common samples incl normal
comSamples <- intersect(rownames(currentAnnot_ruv), colnames(ruvTCGA))

ruvTCGA <- ruvTCGA[, comSamples]
currentAnnot_ruv <- currentAnnot_ruv[comSamples, ]
```


## CMS 
Perform CMS clustering only on Cancer samples, and add this to the annotation data.
```{r}
# devtools::install_github("Lothelab/CMScaller")
set.seed(20201011)

ruvTCGA_tum <- ruvTCGA[, currentAnnot_ruv$shortLetterCode != "NT"]
currentAnnot_ruvTum <- currentAnnot_ruv[colnames(ruvTCGA_tum), ]
  
  
cmsTCGA_ruv <-
  CMScaller::CMScaller(
    emat = ruvTCGA_tum,
    RNAseq = F,
    FDR = 0.05,
    rowNames = "symbol"
  )

currentAnnot_ruv <-
  merge(
    currentAnnot_ruv,
    cmsTCGA_ruv[, "prediction", drop = F],
    by.x = "barcode",
    by.y = "row.names",
    all.x = T
  )

colnames(currentAnnot_ruv)[colnames(currentAnnot_ruv) == "prediction"] <- "CMS"
currentAnnot_ruv$CMS <- as.character(currentAnnot_ruv$CMS)

currentAnnot_ruv$CMS[currentAnnot_ruv$shortLetterCode == "NT"] <- "N"

## removing normal
# CMS1 CMS2 CMS3 CMS4 <NA> 
#   74  129   68  138   30 

row.names(currentAnnot_ruv) <- currentAnnot_ruv$barcode
currentAnnot_ruv <- currentAnnot_ruv[colnames(ruvTCGA), ]

```

## Score corrected TCGA data

AllSigsCollection is a genesetcollection generated in ReadSignatureTum_paper.R script. We score samples against signatures and add the scores to the annotation data.
```{r}
library(singscore)

rd_TCGA_ruv <- rankGenes(ruvTCGA)

tcgaScoresDisp_ruv <- multiScore(rd_TCGA_ruv, 
                         upSetColc = AllSigsCollection, 
                         knownDirection = T, 
                         centerScore = F)

tcgaScores_ruv <-
  data.frame(t(tcgaScoresDisp_ruv$Scores),
             check.rows = F,
             check.names = F)

## Add TGFb-EMT bidirectional scores too:
tcgaScores_ruv$TGFbEMT_Dir <- simpleScore(
  rd_TCGA_ruv,
  upSet = sigsTum$TGFb_EMT$tgfb_Up,
  downSet = sigsTum$TGFb_EMT$tgfb_Dn,
  knownDirection = T,
  centerScore = F
)$TotalScore


# colnames(tcgaScores_ruv) <- gsub("Trm_", "Res_", colnames(tcgaScores_ruv))
scoreNames <- c(colnames(tcgaScores_ruv))
scoreNames <- scoreNames[order(scoreNames)]


##----- Add these to annotation data:
currentAnnot_ruv <-
  data.frame(currentAnnot_ruv ,
             tcgaScores_ruv,
             check.names = F,
             check.rows = F)
```

## Scores vs Annotation

### Define Cancer and Immune signatures
```{r}
## 28 mostly cancer related  signatures
canSigs <- scoreNames[! grepl("Res_", scoreNames) &
                        ! grepl("Exh_", scoreNames)]

## our Res/Exh signatures
imSigs <- scoreNames[grepl("Res_", scoreNames) |
                        grepl("Exh_", scoreNames)]
 
```

### Boxplots stratified by MSI, CMS and tumour location
These reproduces Figure 4A and 4B (left panels) and Suppl Figure 8 (left panel). 
```{r, fig.height = 5, fig.width = 6}
library(ggsignif)

scoreColumns <- which(colnames(currentAnnot_ruv)  %in% scoreNames)

annTCGALong_ruv <- currentAnnot_ruv %>%
  pivot_longer(
    cols = scoreColumns[1]:scoreColumns[length(scoreColumns)],
    names_to = "Signature",
    values_to = "Score"
  ) %>%
  data.frame(check.rows = F, check.names = F)



# pdf(paste0(figPath, "TCGA_Boxplot_Scores_MSI_Bulk.pdf"), height = 6, width = 5.2)

annTCGALong_ruv %>%
  filter(MSI_TCGAbiolink_annot != "Indeterminate") %>% 
  filter(shortLetterCode != "N") %>%
  filter(grepl("Bulk", Signature)) %>%
  filter(! grepl("CD8NK", Signature) & ! grepl("All", Signature)) %>%
  mutate(MSI = MSI_TCGAbiolink_annot) %>% 
  ggplot(., aes(x = MSI, y = Score, color = MSI)) +
  geom_boxplot() +
  geom_signif(
    comparisons = list(c("MSI-H", "MSS")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  facet_wrap( ~ Signature, scales = "free", ncol = 2) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  scale_color_manual(values =  rev(c(brewer.pal(9, "Purples") [c(4, 6, 9)]))) +
  currentTheme +
    theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
        axis.ticks = element_blank(),
    legend.position = "bottom"
    )
# dev.off()



cmsCol <- c(
  brewer.pal(11, "BrBG")[3],
  brewer.pal(11, "PRGn")[2],
  brewer.pal(9, "Blues")[5],
  brewer.pal(11, "BrBG")[10],
  "grey50"
)


# pdf(paste0(figPath, "TCGA_Boxplot_Scores_CMS_Bulk.pdf"), height = 6, width = 5.5)

annTCGALong_ruv %>%
  filter(complete.cases(CMS)) %>%
  filter(grepl("Bulk", Signature)) %>%
  filter(! grepl("CD8NK", Signature) & ! grepl("All", Signature)) %>%
  ggplot(., aes(x = CMS, y = Score, color = CMS)) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap( ~ Signature, scales = "free", ncol = 2) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  scale_color_manual(values = cmsCol) +
  currentTheme +
  theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
        axis.ticks = element_blank(),
    legend.position = "bottom"
    )

# dev.off()


##---- Location
## better to use this: site_of_resection_or_biopsy rather than this: tissue_or_organ_of_origin; These are lists: primary_site and disease_type

# Right - proximal : caecum, asc. colon, hepatic flexure, transverse colon
# Left : Splenic Flexure, Desc Colon, Sigmoid, Rectosigmoid Junction 

rightTum <- c("Cecum", 
              "Ascending colon", 
              "Hepatic flexure of colon",
              "Transverse colon")

leftTum <- c("Sigmoid colon", 
              "Descending colon", 
              "Splenic flexure of colon",
              "Rectosigmoid junction")



annTCGALong_ruv$site_of_resection_or_biopsy[
  annTCGALong_ruv$site_of_resection_or_biopsy %in% rightTum
] <- "Proximal"

annTCGALong_ruv$site_of_resection_or_biopsy[
  annTCGALong_ruv$site_of_resection_or_biopsy %in% leftTum
] <- "Distal"
# 
# pdf(
#   paste0(figPath, "TCGA_Boxplot_Scores_Location_Bulk.pdf"),
#   height = 6,
#   width = 5
# )
annTCGALong_ruv %>%
  filter(complete.cases(site_of_resection_or_biopsy)) %>%
  filter(grepl("Bulk", Signature)) %>%
  filter(! grepl("Colon, NOS", site_of_resection_or_biopsy)) %>%
  filter(! grepl("CD8NK", Signature) & ! grepl("All", Signature)) %>%
  ggplot(., aes(x = site_of_resection_or_biopsy, y = Score, color = site_of_resection_or_biopsy)) +
  geom_boxplot(outlier.shape = NA) +
  ggpubr::geom_signif(
    comparisons = list(c("Distal", "Proximal")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  facet_wrap( ~ Signature, scales = "free", ncol = 2) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  # scale_color_manual(values = c(brewer.pal(9, "Blues") [c(4, 5, 7, 9)], "gray50")) +
  scale_color_manual(values = brewer.pal(8, "Greys")[c(5, 7)]) +
  currentTheme +
  theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
        axis.ticks = element_blank(),
    legend.position = "bottom"
    )
  # theme_bw() 

# dev.off()
```


### Scatterplots of score pairs
Generate scatterplots of scores vs each other. Uncomment the commented sections to change the colour the data points based on CMS or MSI. The first bit of code generates many scatterplots comparing each signature with all other signatures; you could uncomment this section and export that in a PDF file to avoid overloading the html file. Here, we have commented the first section and only generate the scatterplots presented in the paper.

We also generate a heatmap of the correlation values between Res/Exh scores and several selected signature scores. 
```{r}

cmsCol <- c(
  brewer.pal(11, "BrBG")[3],
  brewer.pal(11, "PRGn")[2],
  brewer.pal(9, "Blues")[5],
  brewer.pal(11, "BrBG")[10]
)

# pdf(
#   paste0(
#     figPath,
#     # "ScatterPlots_TCGA_ExhTrmScorePairs_colCMS_rmNormal_Lines.pdf"
#     "ScatterPlots_TCGA_ExhTrmScorePairs_colMSI_rmNormal_Lines.pdf"
#   ),
#   height = 4.7,
#   width = 4.3
# )
# 
# for(im in imSigs) {
#   Others <- imSigs[imSigs != im]
#   
#   for (ot in Others) {
#     
#     d <- currentAnnot_ruv %>%
#       mutate(MSI = MSI_TCGAbiolink_annot) %>%
#       filter(! MSI  %in% "Indeterminate") %>%
#       filter(! CMS  %in% "N") %>%
#       mutate(medIm = median(!!sym(im)),
#              medOt = median(!!sym(ot)))
#       
#     corVal <- round(
#       cor.test(d[, im], d[, ot])[[4]], 2)
#     
#     
#     # palette <- cmsCol
#     palette <- rev(c(brewer.pal(9, "Purples") [c(4, 6, 9)]))
#     
#     pal <- list(values=palette, na.value="gray80")
#     
#     print(
#       d %>% 
#         ggplot(.,
#                # aes_string(im, ot, color = "CMS")) +
#                aes_string(im, ot, color = "MSI")) +
#         geom_point(alpha = 0.8) +
#         invoke(scale_colour_manual, pal) +
#         geom_vline(xintercept = d$medIm) +
#         geom_hline(yintercept = d$medOt) +
#         scale_x_continuous(
#                        breaks = equal_breaks(n = nBreak, s = scalingFactor),
#                        expand = c(scalingFactor, 0)
#                      ) +
#         scale_y_continuous(
#                        breaks = equal_breaks(n = nBreak, s = scalingFactor),
#                        expand = c(scalingFactor, 0)
#                      ) +
#         ggtitle(paste0("TCGA (cor = ", corVal, ")")) +
#         currentTheme + 
#         guides(color = guide_legend(nrow=2)) 
#     )
#   }
# }
# 
# dev.off()


corData <- data.frame(matrix(nrow = 10, ncol = 0))
rownames(corData) <- imSigs

selCanSigs <-
  c(
    "TGFb_Signaling",
    "TGFbEMT",
    "HPX_EGF_EMT",
    "OXPHOS",
    "DDR",
    "DNA_Repair",
    "TP53_pos",
    "TP53_neg"
  )

for(se in selCanSigs) {
  corValues <- vector()
  for (im in imSigs) {
    d <- currentAnnot_ruv %>%
      mutate(MSI = MSI_TCGAbiolink_annot) %>%
      filter(!MSI  %in% "Indeterminate") %>%
      filter(!CMS  %in% "N")
    
    corVal <- round(cor.test(d[, im], d[, se])[[4]], 2)
    names(corVal) <- im
    corValues <- c(corValues, corVal)
    dd <- data.frame(corValues)
  }
  
  corData <- cbind(corData, dd)
}

colnames(corData) <- selCanSigs

library(circlize)
library(grid)

# png(
#   paste0(figPath, "Correlation_ResExh_TGFbSignaling.png"),
#   height = 6,
#   width = 6.5,
#   res = 400,
#   units = "in"
# )
ComplexHeatmap::Heatmap(
  corData,
  cluster_columns = T,
  cluster_rows = F,
  col = viridis::cividis(100),
  column_title = "Correlation of Res and Exh scores with \ndifferent signature scores in TCGA COAD data",
  cell_fun = function(j, i, x, y, width, height, fill) {
    grid.text(sprintf("%.2f", corData[i, j]), x, y, gp = gpar(fontsize = 10))
  }, show_heatmap_legend = T, name = "Pearson's\ncorrelation\ncoefficient\n"
)
# dev.off()

```

**Scatterplot of CD8NK_Exh_Bulk vs TGFb_Signaling, coloured by CMS subtypes (Figure 6B, left scatterplot)**
```{r, fig.height = 4.7, fig.width = 4.3}

x <- "CD8NK_Exh_Bulk"
y <- "TGFb_Signaling"

d <- currentAnnot_ruv %>%
  mutate(MSI = MSI_TCGAbiolink_annot) %>%
  filter(! MSI  %in% "Indeterminate") %>%
  filter(! CMS  %in% "N") %>%
  mutate(medIm = median(!!sym(x)),
         medOt = median(!!sym(y)))

corVal <- round(
  cor.test(d[, x], d[, y])[[4]], 2)


palette <- cmsCol
# palette <- rev(c(brewer.pal(9, "Purples") [c(4, 6, 9)]))

pal <- list(values=palette, na.value="gray80")

print(
  d %>%
    ggplot(.,
           aes_string(x, y, color = "CMS")) +
           # aes_string(x, y, color = "MSI")) +
    geom_point(alpha = 0.8) +
    invoke(scale_colour_manual, pal) +
    geom_vline(xintercept = d$medIm) +
    geom_hline(yintercept = d$medOt) +
    scale_x_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    scale_y_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    ggtitle(paste0("TCGA (cor = ", corVal, ")")) +
    currentTheme +
    guides(color = guide_legend(nrow=2))
)

```

**Scatterplot of CD8NK_Exh_Bulk vs NK_Res_Bulk, coloured by CMS subtypes (Figure 7B, left scatterplot)**
```{r, fig.height = 4.7, fig.width = 4.3}
x <- "CD8NK_Exh_Bulk"
y <- "NK_Res_Bulk"

d <- currentAnnot_ruv %>%
  mutate(MSI = MSI_TCGAbiolink_annot) %>%
  filter(! MSI  %in% "Indeterminate") %>%
  filter(! CMS  %in% "N") %>%
  mutate(medIm = median(!!sym(x)),
         medOt = median(!!sym(y)))

corVal <- round(
  cor.test(d[, x], d[, y])[[4]], 2)


palette <- cmsCol
# palette <- rev(c(brewer.pal(9, "Purples") [c(4, 6, 9)]))

pal <- list(values=palette, na.value="gray80")

print(
  d %>%
    ggplot(.,
           aes_string(x, y, color = "CMS")) +
           # aes_string(x, y, color = "MSI")) +
    geom_point(alpha = 0.8) +
    invoke(scale_colour_manual, pal) +
    geom_vline(xintercept = d$medIm) +
    geom_hline(yintercept = d$medOt) +
    scale_x_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    scale_y_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    ggtitle(paste0("TCGA (cor = ", corVal, ")")) +
    currentTheme +
    guides(color = guide_legend(nrow=2))
)

```


**Scatterplot of CD8NK_Exh_Bulk vs NK_Res_Bulk, coloured by CMS subtypes (Figure 8A, left scatterplot)**
```{r, fig.height = 4.7, fig.width = 4.3}
x <- "NK_Res_Bulk"
y <- "NK_Exh_Bulk"

d <- currentAnnot_ruv %>%
  mutate(MSI = MSI_TCGAbiolink_annot) %>%
  filter(! MSI  %in% "Indeterminate") %>%
  filter(! CMS  %in% "N") %>%
  mutate(medIm = median(!!sym(x)),
         medOt = median(!!sym(y)))

corVal <- round(
  cor.test(d[, x], d[, y])[[4]], 2)


palette <- cmsCol
# palette <- rev(c(brewer.pal(9, "Purples") [c(4, 6, 9)]))

pal <- list(values=palette, na.value="gray80")

print(
  d %>%
    ggplot(.,
           aes_string(x, y, color = "CMS")) +
           # aes_string(x, y, color = "MSI")) +
    geom_point(alpha = 0.8) +
    invoke(scale_colour_manual, pal) +
    geom_vline(xintercept = d$medIm) +
    geom_hline(yintercept = d$medOt) +
    scale_x_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    scale_y_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    ggtitle(paste0("TCGA (cor = ", corVal, ")")) +
    currentTheme +
    guides(color = guide_legend(nrow=2))
)

```

# OS 
```{r}
library(survival)
timeCol = "OS.time"
eventCol = "OS"

annFilt <- currentAnnot_ruv[currentAnnot_ruv$shortLetterCode != "NT", ]

medAge <- median(as.numeric(annFilt$Age), na.rm = T)

annFilt$Age_status <- NA
annFilt$Age_status[annFilt$Age < medAge] <- "Young"
annFilt$Age_status[annFilt$Age >= medAge] <- "Old"

# covs <- c("Age", "Stage", "MSI_TCGAbiolink_annot", "gender", "CMS")

annFilt <- annFilt[complete.cases(annFilt$Age), ]
annFilt <- annFilt[complete.cases(annFilt[, timeCol]), ]
annFilt$MSI_TCGAbiolink_annot[annFilt$MSI_TCGAbiolink_annot == "Indeterminate"] <- NA

```

## Lasso for Cox to select covariates
In order to decide which of the clinical factors to include, we perform lasso on the Cox models. We then use the coef of the lambda.min to decide which ones to include or exclude from the model. Based on the results below, we decide include all 4 main variables: MSI, CMS, Age and Stage, as they all had non-zero lambda.min.
```{r}
library(tidyverse)
library(broom)
library(glmnet)

set.seed(20201214)

currentAnnot_ruvSel <-
  currentAnnot_ruv[! currentAnnot_ruv$shortLetterCode  %in%  "NT" &
                   ! duplicated(currentAnnot_ruv$Sample.ID), c(
    "MSI_TCGAbiolink_annot",
    "CMS",
    "Age",
    "Stage",
    "OS.time",
    "OS"
  )]
currentAnnot_ruvSel$MSI_TCGAbiolink_annot[currentAnnot_ruvSel$MSI_TCGAbiolink_annot == "Indeterminate"] <- NA

currentAnnot_ruvSel <- currentAnnot_ruvSel[complete.cases(currentAnnot_ruvSel) &
currentAnnot_ruvSel$OS.time > 0,]


pred <- currentAnnot_ruvSel[, 
                          ! colnames(currentAnnot_ruvSel)  %in% c(timeCol, eventCol)]

x <- model.matrix(~ MSI_TCGAbiolink_annot + CMS + Age + Stage, pred)


y <- as.matrix(currentAnnot_ruvSel[, c(timeCol, eventCol)])
colnames(y) <- c("time", "status")

fit <- glmnet(
  x = x, 
  y = y, 
  family = "cox",
  alpha = 1)


plot(fit, label = T)
cv.fit <- cv.glmnet(x, y, family = "cox", alpha = 1)
plot(cv.fit)


coef(cv.fit, s = "lambda.min")


coxph(Surv(as.numeric(currentAnnot_ruvSel[, timeCol]), as.numeric(currentAnnot_ruvSel[, eventCol])) ~
        Age + Stage + MSI_TCGAbiolink_annot + CMS,
      data = currentAnnot_ruvSel)

```


## Generate different format of the data

### Wide, 2/3 group scores/gene
```{r}

scoreColumns <- which(colnames(annFilt) %in% scoreNames)

wide2 <- data.frame(
  ## keep annotations and stage and age
  annFilt[, c(1:151)],
  ## add two group scores and genes
  as.data.frame(sapply(c(scoreNames), function(x) {
  case_when(
    annFilt[, x] >= median(annFilt[, x], na.rm = T) ~ "High",
    annFilt[, x] < median(annFilt[, x], na.rm = T) ~ "Low"
  )
}), check.names = F)
, check.names = F)


wide3 <- data.frame(## keep annotations and stage and age
  annFilt[, c(1:151)],
  ## add two group scores and genes
  as.data.frame(sapply(c(scoreNames), function(x) {
    case_when(
      annFilt[, x] >= quantile(annFilt[, x], probs = 0.65) ~ "High",
      annFilt[, x] <= quantile(annFilt[, x], probs = 0.35) ~ "Low",
      
      annFilt[, x] > quantile(annFilt[, x], probs = 0.35) &
        annFilt[, x] < quantile(annFilt[, x], probs = 0.65)  ~ "Intermediate"
    )
  }), check.names = F)
, check.names = F)
```

### Long 2/3 groups score/gene
```{r}

scoreAnnot <- pivot_longer(annFilt, 
                           cols = scoreColumns[1]:scoreColumns[length(scoreColumns)], 
                           values_to = "Score",
                           names_to = "Signature") %>% 
  data.frame()


scoreAnnot <- scoreAnnot %>%
  data.frame() %>%
  group_by(Signature) %>%
  # mutate(MedianScore = median(TotalScore)) %>%
  mutate(
    MedianScore = median(Score),
    Quantile_low = quantile(Score, probs = 0.35),
    Quantile_High = quantile(Score, probs = 0.65),
    Score_2status = case_when(
      Score >= MedianScore ~ "High score",
      Score < MedianScore ~ "Low score"
    ),
    Score_3status = case_when(
      Score >= Quantile_High ~ "High score",
      Score <= Quantile_low ~ "Low score",
      Score < Quantile_High &
        Score > Quantile_low ~ "Intermediate score"
    )
  ) %>%
  data.frame()

```


### OS: Score + covariates
We use our custom function (coxph_multitest) for performing coxph test on several signatures at the same time. We perform the analysis twice, once by grouping samples into two group based on Median scores, and once by grouping them into 3 groups based on the top and bottom 33%-tile. 

None of the Res_Bulk/Exh_Bulk signatures alone are significantly associated with OS (after taking into account the 4 covariates).  

* Significant signature scores associated with OS when considering 2 groups:  WNT and TGFb signalling
* Significant signature scores associated with OS when considering 3 groups: Antigen presentation, Glycolysis, and WNT


```{r}
covarColumns <- c("Age", "Stage", "CMS", "MSI_TCGAbiolink_annot")

cox_OS_Score_2groups_AgeStage <-
  coxph_multitest(
    data = scoreAnnot,
    variableNameCol = "Signature",
    variableCol = "Score_2status",
    timeCol = "OS.time",
    eventCol = "OS",
    nStrata = 2,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )

cox_OS_Score_2groups_AgeStage_sig <- cox_OS_Score_2groups_AgeStage %>% filter(`Pr(>|z|)` < 0.05) %>% 
  data.frame(check.names = F)


cox_OS_Score_3groups_AgeStage <-
  coxph_multitest(
    data = scoreAnnot,
    variableNameCol = "Signature",
    variableCol = "Score_3status",
    timeCol = "OS.time",
    eventCol = "OS",
    nStrata = 3,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )

cox_OS_Score_3groups_AgeStage_sig <- cox_OS_Score_3groups_AgeStage %>% filter(`Pr(>|z|)` < 0.05) %>% 
  data.frame(check.names = F)

```


### OS: Score Pairs + covariates
Here, we examine if stratifying samples based on any two signature scores are associated with survival outcome (by considering the 4 covariates).
```{r}

trmSigs <- c(
  "CD8_Res_Bulk",
  "CD4_Res_Bulk",
  "NK_Res_Bulk",
  "All_Res_Bulk", 
  "CD8NK_Res_Bulk"
  )

exhSigs <- c(
  "CD8_Exh_Bulk",
  "CD4_Exh_Bulk",
  "NK_Exh_Bulk",
  "All_Exh_Bulk",
  "CD8NK_Exh_Bulk"
  )

# selSigs <- c(trmSigs, exhSigs, TGFbGenes)

exhTGFbCan <- c(exhSigs, canSigs)
trmTGFbCan <- c(trmSigs, canSigs)


wide2Comb <- wide2

for(s in trmSigs){
  for(e in exhTGFbCan){
    currentColumn <- paste(s, e, sep = "--")
    wide2Comb[, currentColumn] <- paste(wide2Comb[, s], s , "&",
                                      wide2Comb[, e], e)
  }
} 
  
for(s in exhSigs){
  for(e in trmTGFbCan){
    currentColumn <- paste(s, e, sep = "--")
    wide2Comb[, currentColumn] <- paste(wide2Comb[, s], s , "&",
                                      wide2Comb[, e], e)
  }
}  
 
wide2Comb[, "CD8_Res_Bulk--CD4_Res_Bulk"] <-
  paste(wide2Comb[, "CD8_Res_Bulk"],
        "CD8_Res_Bulk" ,
        "&",
        wide2Comb[, "CD4_Res_Bulk"],
        "CD4_Res_Bulk")
 
wide2Comb[, "CD8_Res_Bulk--NK_Res_Bulk"] <-
  paste(wide2Comb[, "CD8_Res_Bulk"],
        "CD8_Res_Bulk" ,
        "&",
        wide2Comb[, "NK_Res_Bulk"],
        "NK_Res_Bulk")
 
wide2Comb[, "CD4_Res_Bulk--NK_Res_Bulk"] <-
  paste(wide2Comb[, "CD4_Res_Bulk"],
        "CD4_Res_Bulk" ,
        "&",
        wide2Comb[, "NK_Res_Bulk"],
        "NK_Res_Bulk")

 
wide2Comb[, "CD8_Exh_Bulk--CD4_Exh_Bulk"] <-
  paste(wide2Comb[, "CD8_Exh_Bulk"],
        "CD8_Exh_Bulk" ,
        "&",
        wide2Comb[, "CD4_Exh_Bulk"],
        "CD4_Exh_Bulk")
 
wide2Comb[, "CD8_Exh_Bulk--NK_Exh_Bulk"] <-
  paste(wide2Comb[, "CD8_Exh_Bulk"],
        "CD8_Exh_Bulk" ,
        "&",
        wide2Comb[, "NK_Exh_Bulk"],
        "NK_Exh_Bulk")
 
wide2Comb[, "CD4_Exh_Bulk--NK_Exh_Bulk"] <-
  paste(wide2Comb[, "CD4_Exh_Bulk"],
        "CD4_Exh_Bulk" ,
        "&",
        wide2Comb[, "NK_Exh_Bulk"],
        "NK_Exh_Bulk")


wide2CombLong <- wide2Comb %>%
  pivot_longer(
    .,
    cols = 190:ncol(wide2Comb),
    values_to = "Comb_2status",
    names_to = "Comb_Name"
  ) %>%
  data.frame()
  

saveRDS(wide2CombLong, paste0(outPath, "TCGA_Survival_OS_ScoreExpr_wide.RDS"))
```

The below combination of signatures are significantly associated with OS:
```{r}
cox_OS_2Comb_AgeStage <-
  coxph_multitest(
    data = wide2CombLong,
    variableNameCol = "Comb_Name",
    variableCol = "Comb_2status",
    timeCol = "OS.time",
    eventCol = "OS",
    nStrata = 4,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )


cox_OS_2Comb_AgeStage_sig <-
  cox_OS_2Comb_AgeStage %>% filter(`Pr(>|z|)` < 0.05) %>%
  data.frame(check.names = F)


cox_OS_2Comb_AgeStage_sig$variable

write.csv(
  cox_OS_2Comb_AgeStage,
  paste0(outPath, "TCGA_COAD_RUV_Cox_OS_2ScorePairs_AllStat.csv"),
  row.names = F
)

write.csv(
  cox_OS_2Comb_AgeStage_sig,
  paste0(outPath, "TCGA_COAD_RUV_Cox_OS_2ScorePairs_significant.csv"),
  row.names = F
)

```

```{r}
wide2CombLong$OS.time <- wide2CombLong$OS.time/12
```

K-M curves for the significant score combinations. The reported p-values in the below figures are log-rank p-values, and while the p-values from the multivariate Cox prop hazard models are significant for all these signature pairs, the log-rank may not be significant. One of these figures reproduces Figure 6C, left plot. 
```{r, fig.height = 5.2, fig.width = 4.6}
sigPairs <- unique(cox_OS_2Comb_AgeStage_sig$VariableName)
covarInfo <- paste(covarColumns, collapse = " + ")
sn <- "OS"

# Uncomment the below code to see the corrected curves (taking into account the covariates)
# pdf(
#   paste0(figPath, "OS_TCGA_RUV_2ScorePairs_Cox_CorrectedCurves.pdf"),
#   height = 4,
#   width = 8
# )
# 
# for (cc in sigPairs) {
#   variableCol <- "Comb_2status"
#   ggSurv <- wide2CombLong[wide2CombLong$Comb_Name == cc,]
#   currentCoxFit <-  coxph(as.formula(
#     paste(
#       'Surv(',
#       timeCol,
#       ', ',
#       eventCol,
#       ')~',
#       variableCol,
#       ' + ',
#       covarInfo
#     )
#   )
#   ,
#   data = ggSurv)
#   
#   
#   print(
#     survminer::ggadjustedcurves(
#       currentCoxFit,
#       method = "average",
#       variable = variableCol,
#       data = ggSurv,
#       palette = rev(brewer.pal(10, "Paired")),
#       title = cc,
#       legend = "right"
#     )
#   )
#   
# }
# dev.off()



# pdf(
#   paste0(figPath, "OS_TCGA_RUV_2ScorePairs_Cox.pdf"),
#   height = 5.2,
#   width = 4.6
# )
for(cc in sigPairs){
  
  sc1 <- unlist(strsplit(cc, "--"))[1]
  sc2 <- unlist(strsplit(cc, "--"))[2]
  
   print(survival_plot(data = 
                         ruvTCGA_tum[, rownames(annFilt)],
                          stratify = "score_score",
                          annot = annFilt,
                          scoreCol = c(sc1, sc2),
                          gene = NULL,
                          covariate = NULL,
                          isCategoricalCov = NULL,
                          timeCol = paste0(sn, ".time"),
                          eventCol = sn,
                          nGroup = 2,
                          confInt = F, 
                          ylabel = sn,
                          cols = 
                            (brewer.pal(8, "Dark2"))))
}
# dev.off()

```


### ScorePairs extremes
We run the Cox model only on samples from the top left and bottom right of the scattreplots of Res_Bulk vs Exh_Bulk scores; i.e. we compare samples with high Res and low Exh to those with low Res and high Exh scores. Significant associations are from the below combinations of signatures:

* "CD8_Exh_Bulk--NK_Res_Bulk" 
* "CD4_Res_Bulk--NK_Res_Bulk" 
* "CD4_Res_Bulk--CD8_Exh_Bulk"
* "NK_Res_Bulk--NK_Exh_Bulk"  

One of the survival plots generated here, reproduces Figure 8B, left panel.
```{r, fig.height = 5.8, fig.width = 6}
selComb <- c(
  "Low CD8_Res_Bulk & High CD8_Exh_Bulk",
  "High CD8_Res_Bulk & Low CD8_Exh_Bulk",
  
  "Low CD4_Res_Bulk & High CD4_Exh_Bulk",
  "High CD4_Res_Bulk & Low CD4_Exh_Bulk",
  
  "Low NK_Res_Bulk & High NK_Exh_Bulk",
  "High NK_Res_Bulk & Low NK_Exh_Bulk",
  
  "Low All_Exh_Bulk & High All_Res_Bulk",
  "High All_Exh_Bulk & Low All_Res_Bulk",
  

  "High CD8_Res_Bulk & Low NK_Exh_Bulk",
  "Low CD8_Res_Bulk & High NK_Exh_Bulk",
  
  "High CD4_Res_Bulk & Low NK_Exh_Bulk",
  "Low CD4_Res_Bulk & High NK_Exh_Bulk",
  
  "High CD4_Res_Bulk & Low CD8_Exh_Bulk",
  "Low CD4_Res_Bulk & High CD8_Exh_Bulk",
  
  "High CD8_Exh_Bulk & Low NK_Res_Bulk",
  "Low CD8_Exh_Bulk & High NK_Res_Bulk",
  
  
  "High CD8_Exh_Bulk & Low NK_Exh_Bulk",
  "Low CD8_Exh_Bulk & High NK_Exh_Bulk",
  
  "High CD8_Exh_Bulk & Low CD4_Exh_Bulk",
  "Low CD8_Exh_Bulk & High CD4_Exh_Bulk",
  
  "High CD4_Exh_Bulk & Low NK_Exh_Bulk",
  "Low CD4_Exh_Bulk & High NK_Exh_Bulk",
  
  
  "High CD8_Res_Bulk & Low NK_Res_Bulk",
  "Low CD8_Res_Bulk & High NK_Res_Bulk",
  
  "High CD8_Res_Bulk & Low CD4_Res_Bulk",
  "Low CD8_Res_Bulk & High CD4_Res_Bulk",
  
  "High CD4_Res_Bulk & Low NK_Res_Bulk",
  "Low CD4_Res_Bulk & High NK_Res_Bulk", 
  

  "High CD8NK_Exh_Bulk & Low CD8NK_Res_Bulk",
  "Low CD8NK_Exh_Bulk & High CD8NK_Res_Bulk"
)

# wide2CombLong$OS.time <- wide2CombLong$OS.time/12
wide2CombLongSel <- wide2CombLong[wide2CombLong$Comb_2status  %in% selComb,]


cox_OS_2Comb_AgeStage_Extremes <-
  coxph_multitest(
    data = wide2CombLongSel,
    variableNameCol = "Comb_Name",
    variableCol = "Comb_2status",
    timeCol = "OS.time",
    eventCol = "OS",
    nStrata = 2,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )
 

cox_OS_2Comb_AgeStage_Extremes_sig <-
  cox_OS_2Comb_AgeStage_Extremes %>% filter(`Pr(>|z|)` <= 0.05) %>%
  data.frame(check.names = F)

# [1] "CD8_Exh_Bulk--NK_Res_Bulk" 
# [2] "CD4_Res_Bulk--NK_Res_Bulk" 
# [3] "CD4_Res_Bulk--CD8_Exh_Bulk"
# [4] "NK_Res_Bulk--NK_Exh_Bulk"  

# pdf(
#   paste0(figPath, "OS_TCGA_ExtremeScorePairs_Cox.pdf"),
#   height = 5.8,
#   width = 6
# )

for (cc in cox_OS_2Comb_AgeStage_Extremes_sig$VariableName) {
  annot <-
    wide2CombLongSel[wide2CombLongSel$Comb_Name == cc, ]
  
  annot[, timeCol] <- as.numeric(annot[, timeCol])
  annot[, eventCol] <- as.numeric(annot[, eventCol])
  
  fitValues <- survfit(Surv(time = annot[, timeCol],
                            event = annot[, eventCol]) ~
                         annot$Comb_2status)
  
  nSamples <- as.numeric(table(annot$Comb_2status)[1])
  pValCox <- cox_OS_2Comb_AgeStage_Extremes_sig$`Pr(>|z|)`[cox_OS_2Comb_AgeStage_Extremes_sig$VariableName == cc]
  
  if (pValCox < 0.01) {
    pValCox <- " < 0.01"
  } else {
    pValCox <- paste0(" = ", round(pValCox, 3))
  }
  
  print(survminer::ggsurvplot (
    fitValues,
    data = annot,
    fun = "pct",
    pval = T,
    conf.int = F,
    palette = cols,
    xlab = "Time",
    legend.title = "",
    title = "TCGA",
    subtitle = paste0("p-value (Cox)", pValCox, ";", " N = ", nSamples, " in each group"),
    # legend.labs = c("High CD4_Exh & Low NK_Exh", "Low CD4_Exh & High NK_Exh"),
    legend = c(.5, .2),
    font.x = 20,
    font.y = 20,
    font.tickslab = 18,
    font.main = 20,
    font.submain = c(17, "italic"),
    font.legend = 11

  ))

}
# dev.off()


write.csv(cox_OS_2Comb_AgeStage_Extremes_sig, 
          paste0(outPath, "TCGA_Cox_OS_ExtremeScorePairs_significant.csv"), 
          row.names = F)
```
Plot of Cox coef 
```{r}
dd <- cox_OS_2Comb_AgeStage_Extremes_sig[, c("VariableName",
                                             "variable",
                                             "exp(coef)",
                                             "lower .95",
                                             "upper .95",
                                             "z",
                                             "Pr(>|z|)")]

colnames(dd) <-
  c("VariableName",
    "term",
    "estimate",
    "conf.low",
    "conf.high",
    "z",
    "p-value")


dd <- dd[order(dd$estimate), ]


# pdf(
#   paste0(figPath, "OS_TCGA_RUV_CoefPlot_ScorePairsExtremes.pdf"),
#   height = 1.5,
#   width = 6.5
# )
ggstatsplot::ggcoefstats(
  x = dd,
  output = "plot",
  statistic = "z",
  exponentiate = T
)
# dev.off()
```


# PFI 

```{r}
library(survival)
timeCol = "PFI.time"
eventCol = "PFI"
sn <- "PFI"

annFilt <- currentAnnot_ruv[currentAnnot_ruv$shortLetterCode != "NT", ]

medAge <- median(as.numeric(annFilt$Age), na.rm = T)

annFilt <- annFilt[complete.cases(annFilt$Age), ]
annFilt <- annFilt[complete.cases(annFilt[, timeCol]), ]

annFilt$Age_status <- NA
annFilt$Age_status[annFilt$Age < medAge] <- "Young"
annFilt$Age_status[annFilt$Age >= medAge] <- "Old"

annFilt$MSI_TCGAbiolink_annot[annFilt$MSI_TCGAbiolink_annot == "Indeterminate"] <- NA

```

## Lasso for Cox to select covariates
In order to decide which of the clinical factors to include, we need to perform lasso on the Cox models. We then use the coef of the lambda.min to decide which ones to include or exclude from the model. Based on the results below, we need to include all 4 variables.
```{r}
library(tidyverse)
library(broom)
library(glmnet)

set.seed(20201214)

currentAnnot_ruvSel <-
  currentAnnot_ruv[! currentAnnot_ruv$shortLetterCode  %in%  "NT" &
                   ! duplicated(currentAnnot_ruv$Sample.ID), c(
    "MSI_TCGAbiolink_annot",
    "CMS",
    "Age",
    "Stage",
    timeCol,
    eventCol
  )]

currentAnnot_ruvSel$MSI_TCGAbiolink_annot[currentAnnot_ruvSel$MSI_TCGAbiolink_annot == "Indeterminate"] <- NA

currentAnnot_ruvSel <- currentAnnot_ruvSel[complete.cases(currentAnnot_ruvSel) &
currentAnnot_ruvSel[, timeCol] > 0,]

# sur <- Surv(
#   time = as.numeric(currentAnnot_ruvSel[, timeCol]), 
#   event = as.numeric(currentAnnot_ruvSel[, eventCol])) 


pred <- currentAnnot_ruvSel[, 
                          ! colnames(currentAnnot_ruvSel)  %in% c(timeCol, eventCol)]

x <- model.matrix(~ MSI_TCGAbiolink_annot + CMS + Age + Stage, pred)


y <- as.matrix(currentAnnot_ruvSel[, c(timeCol, eventCol)])
colnames(y) <- c("time", "status")

fit <- glmnet(
  x = x, 
  y = y, 
  family = "cox",
  alpha = 1)

plot(fit, label = T)
cv.fit <- cv.glmnet(x, y, family = "cox", alpha = 1)
plot(cv.fit)


coef(cv.fit, s = "lambda.min")


coxph(Surv(as.numeric(currentAnnot_ruvSel[, timeCol]), as.numeric(currentAnnot_ruvSel[, eventCol])) ~
        Age + Stage + MSI_TCGAbiolink_annot + CMS,
      data = currentAnnot_ruvSel)

```

## Generate different formats of the data

### Wide, 2/3 group scores/gene
```{r}

scoreColumns <- which(colnames(annFilt) %in% scoreNames)

wide2 <- data.frame(
  ## keep annotations and stage and age
  annFilt[, c(1:151)],
  ## add two group scores and genes
  as.data.frame(sapply(c(scoreNames), function(x) {
  case_when(
    annFilt[, x] >= median(annFilt[, x], na.rm = T) ~ "High",
    annFilt[, x] < median(annFilt[, x], na.rm = T) ~ "Low"
  )
}), check.names = F)
, check.names = F)


wide3 <- data.frame(## keep annotations and stage and age
  annFilt[, c(1:151)],
  ## add two group scores and genes
  as.data.frame(sapply(c(scoreNames), function(x) {
    case_when(
      annFilt[, x] >= quantile(annFilt[, x], probs = 0.65) ~ "High",
      annFilt[, x] <= quantile(annFilt[, x], probs = 0.35) ~ "Low",
      
      annFilt[, x] > quantile(annFilt[, x], probs = 0.35) &
        annFilt[, x] < quantile(annFilt[, x], probs = 0.65)  ~ "Intermediate"
    )
  }), check.names = F)
, check.names = F)
```

### Long 2/3 groups score/gene
```{r}

scoreAnnot <- pivot_longer(annFilt, 
                           cols = scoreColumns[1]:scoreColumns[length(scoreColumns)], 
                           values_to = "Score",
                           names_to = "Signature") %>% 
  data.frame()


scoreAnnot <- scoreAnnot %>%
  data.frame() %>%
  group_by(Signature) %>%
  # mutate(MedianScore = median(TotalScore)) %>%
  mutate(
    MedianScore = median(Score),
    Quantile_low = quantile(Score, probs = 0.35),
    Quantile_High = quantile(Score, probs = 0.65),
    Score_2status = case_when(
      Score >= MedianScore ~ "High score",
      Score < MedianScore ~ "Low score"
    ),
    Score_3status = case_when(
      Score >= Quantile_High ~ "High score",
      Score <= Quantile_low ~ "Low score",
      Score < Quantile_High &
        Score > Quantile_low ~ "Intermediate score"
    )
  ) %>%
  data.frame()


```


### PFI: Score + covariates
We use our custom function (coxph_multitest) for performing coxph test on several signatures at the same time. We perform the analysis twice, once by grouping samples into two group based on Median scores, and once by grouping them into 3 groups based on the top and bottom 35%-tile. 


* Significant signature scores associated with PFI when considering 2 groups: TGFb_Signaling, NK_Res_Bulk.
* Significant signature scores associated with PFI when considering 3 groups: CD8_Res_Bulk

```{r}
covarColumns <- c("Age", "Stage", "CMS", "MSI_TCGAbiolink_annot")

cox_PFI_Score_2groups <-
  coxph_multitest(
    data = scoreAnnot,
    variableNameCol = "Signature",
    variableCol = "Score_2status",
    timeCol = timeCol,
    eventCol = eventCol,
    nStrata = 2,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )

cox_PFI_Score_2groups_sig <- cox_PFI_Score_2groups %>% filter(`Pr(>|z|)` < 0.05) %>% 
  data.frame(check.names = F)

cox_PFI_Score_2groups_sig$VariableName

# write.csv(
#   cox_PFI_Score_2groups,
#   paste0(outPath, "TCGA_COAD_RUV_Cox_PFI_Score_2groups_AllStat.csv"),
#   row.names = F
# )


cox_PFI_Score_3groups <-
  coxph_multitest(
    data = scoreAnnot,
    variableNameCol = "Signature",
    variableCol = "Score_3status",
    timeCol = timeCol,
    eventCol = eventCol,
    nStrata = 3,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )

cox_PFI_Score_3groups_sig <- cox_PFI_Score_3groups %>% filter(`Pr(>|z|)` < 0.05) %>% 
  data.frame(check.names = F)

cox_PFI_Score_3groups_sig$VariableName

# write.csv(
#   cox_PFI_Score_3groups,
#   paste0(outPath, "TCGA_COAD_RUV_Cox_PFI_Score_3groups_AllStat.csv"),
#   row.names = F
# )
```

Plot survival for the significant score (NK_Res_Bulk and TGFb signaling) - related to Suppl Figure 13.
```{r}

# pdf(
#   paste0(figPath, "PFI_TCGA_Score2groups_Cox.pdf"),
#   height = 4,
#   width = 3.5
# )

for (s in unique(cox_PFI_Score_2groups_sig$VariableName)) {
  print(
    survival_plot(
      data =
        ruvTCGA_tum[, rownames(annFilt)],
      # stratify = "expr",
      stratify = "score",
      annot = annFilt,
      scoreCol =  s,
      gene = NULL,
      covariate = NULL,
      isCategoricalCov = TRUE,
      timeCol = paste0(sn, ".time"),
      eventCol = sn,
      nGroup = 2,
      confInt = F,
      ylabel = paste0(sn),
      cols =
        rev(brewer.pal(10, "Paired"))
    )
  )
}

# dev.off()
```

### PFI: Score Pairs + covariates
```{r}

trmSigs <- c(
  "CD8_Res_Bulk",
  "CD4_Res_Bulk",
  "NK_Res_Bulk",
  "All_Res_Bulk", 
  "CD8NK_Res_Bulk"
  )

exhSigs <- c(
  "CD8_Exh_Bulk",
  "CD4_Exh_Bulk",
  "NK_Exh_Bulk",
  "All_Exh_Bulk",
  "CD8NK_Exh_Bulk"
  )

# selSigs <- c(trmSigs, exhSigs, TGFbGenes)

exhTGFbCan <- c(exhSigs, canSigs)
trmTGFbCan <- c(trmSigs, canSigs)


wide2Comb <- wide2

for(s in trmSigs){
  for(e in exhTGFbCan){
    currentColumn <- paste(s, e, sep = "--")
    wide2Comb[, currentColumn] <- paste(wide2Comb[, s], s , "&",
                                      wide2Comb[, e], e)
  }
} 
  
for(s in exhSigs){
  for(e in trmTGFbCan){
    currentColumn <- paste(s, e, sep = "--")
    wide2Comb[, currentColumn] <- paste(wide2Comb[, s], s , "&",
                                      wide2Comb[, e], e)
  }
}  
 
wide2Comb[, "CD8_Res_Bulk--CD4_Res_Bulk"] <-
  paste(wide2Comb[, "CD8_Res_Bulk"],
        "CD8_Res_Bulk" ,
        "&",
        wide2Comb[, "CD4_Res_Bulk"],
        "CD4_Res_Bulk")
 
wide2Comb[, "CD8_Res_Bulk--NK_Res_Bulk"] <-
  paste(wide2Comb[, "CD8_Res_Bulk"],
        "CD8_Res_Bulk" ,
        "&",
        wide2Comb[, "NK_Res_Bulk"],
        "NK_Res_Bulk")
 
wide2Comb[, "CD4_Res_Bulk--NK_Res_Bulk"] <-
  paste(wide2Comb[, "CD4_Res_Bulk"],
        "CD4_Res_Bulk" ,
        "&",
        wide2Comb[, "NK_Res_Bulk"],
        "NK_Res_Bulk")

 
wide2Comb[, "CD8_Exh_Bulk--CD4_Exh_Bulk"] <-
  paste(wide2Comb[, "CD8_Exh_Bulk"],
        "CD8_Exh_Bulk" ,
        "&",
        wide2Comb[, "CD4_Exh_Bulk"],
        "CD4_Exh_Bulk")
 
wide2Comb[, "CD8_Exh_Bulk--NK_Exh_Bulk"] <-
  paste(wide2Comb[, "CD8_Exh_Bulk"],
        "CD8_Exh_Bulk" ,
        "&",
        wide2Comb[, "NK_Exh_Bulk"],
        "NK_Exh_Bulk")
 
wide2Comb[, "CD4_Exh_Bulk--NK_Exh_Bulk"] <-
  paste(wide2Comb[, "CD4_Exh_Bulk"],
        "CD4_Exh_Bulk" ,
        "&",
        wide2Comb[, "NK_Exh_Bulk"],
        "NK_Exh_Bulk")


wide2CombLong <- wide2Comb %>%
  pivot_longer(
    .,
    cols = 190:ncol(wide2Comb),
    values_to = "Comb_2status",
    names_to = "Comb_Name"
  ) %>%
  data.frame()
  

saveRDS(wide2CombLong, paste0(outPath, "TCGA_Survival_PFI_ScoreExpr_wide.RDS"))
```

55 significant variables
```{r}
cox_PFI_2Comb <-
  coxph_multitest(
    data = wide2CombLong,
    variableNameCol = "Comb_Name",
    variableCol = "Comb_2status",
    timeCol = timeCol,
    eventCol = eventCol,
    nStrata = 4,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )


cox_PFI_2Comb_sig <-
  cox_PFI_2Comb %>% filter(`Pr(>|z|)` < 0.05) %>%
  data.frame(check.names = F)


write.csv(
  cox_PFI_2Comb,
  paste0(outPath, "TCGA_COAD_RUV_Cox_PFI_2ScorePairs_AllStat.csv"),
  row.names = F
)

write.csv(
  cox_PFI_2Comb_sig,
  paste0(outPath, "TCGA_COAD_RUV_Cox_PFI_2ScorePairs_significant.csv"),
  row.names = F
)

```

```{r}
wide2CombLong$PFI.time <- wide2CombLong$PFI.time/12
```



### ScorePairs extremes
We run the Cox model only on samples from the top left and bottom right of the scattreplots of Res_Bulk vs Exh_Bulk scores; i.e. we compare samples with high Res and low Exh to those with low Res and high Exh scores. Significant associations are from the below combinations of signatures:

 * "CD8_Res_Bulk--CD8_Exh_Bulk"    
 * "CD4_Res_Bulk--NK_Exh_Bulk"     
 * "CD8_Exh_Bulk--NK_Res_Bulk"     
 * "CD8_Res_Bulk--NK_Exh_Bulk"     
 * "CD4_Res_Bulk--CD8_Exh_Bulk"    
 * "CD4_Res_Bulk--CD4_Exh_Bulk"    
 * "NK_Res_Bulk--NK_Exh_Bulk"      
 * "CD8NK_Exh_Bulk--CD8NK_Res_Bulk"

One of the survival plots generated here, reproduces Figure 8C, left panel.
```{r, fig.height = 5.8, fig.width = 6}
selComb <- c(
  "Low CD8_Res_Bulk & High CD8_Exh_Bulk",
  "High CD8_Res_Bulk & Low CD8_Exh_Bulk",
  
  "Low CD4_Res_Bulk & High CD4_Exh_Bulk",
  "High CD4_Res_Bulk & Low CD4_Exh_Bulk",
  
  "Low NK_Res_Bulk & High NK_Exh_Bulk",
  "High NK_Res_Bulk & Low NK_Exh_Bulk",
  
  "Low All_Exh_Bulk & High All_Res_Bulk",
  "High All_Exh_Bulk & Low All_Res_Bulk",


  "High CD8_Res_Bulk & Low NK_Exh_Bulk",
  "Low CD8_Res_Bulk & High NK_Exh_Bulk",
  
  "High CD4_Res_Bulk & Low NK_Exh_Bulk",
  "Low CD4_Res_Bulk & High NK_Exh_Bulk",
  
  "High CD4_Res_Bulk & Low CD8_Exh_Bulk",
  "Low CD4_Res_Bulk & High CD8_Exh_Bulk",
  
  "High CD8_Exh_Bulk & Low NK_Res_Bulk",
  "Low CD8_Exh_Bulk & High NK_Res_Bulk",
  
  
  "High CD8_Exh_Bulk & Low NK_Exh_Bulk",
  "Low CD8_Exh_Bulk & High NK_Exh_Bulk",
  
  "High CD8_Exh_Bulk & Low CD4_Exh_Bulk",
  "Low CD8_Exh_Bulk & High CD4_Exh_Bulk",
  
  "High CD4_Exh_Bulk & Low NK_Exh_Bulk",
  "Low CD4_Exh_Bulk & High NK_Exh_Bulk",
  
  
  "High CD8_Res_Bulk & Low NK_Res_Bulk",
  "Low CD8_Res_Bulk & High NK_Res_Bulk",
  
  "High CD8_Res_Bulk & Low CD4_Res_Bulk",
  "Low CD8_Res_Bulk & High CD4_Res_Bulk",
  
  "High CD4_Res_Bulk & Low NK_Res_Bulk",
  "Low CD4_Res_Bulk & High NK_Res_Bulk", 
  
  "High CD8NK_Exh_Bulk & Low CD8NK_Res_Bulk",
  "Low CD8NK_Exh_Bulk & High CD8NK_Res_Bulk"
)


# wide2CombLong <- dListPFI$wide2CombLong
wide2CombLongSel <- wide2CombLong[wide2CombLong$Comb_2status  %in% selComb,]

timeCol <- "PFI.time"
eventCol <- "PFI"

cox_PFI_2Comb_Extremes <-
  coxph_multitest(
    data = wide2CombLongSel,
    variableNameCol = "Comb_Name",
    variableCol = "Comb_2status",
    timeCol = timeCol,
    eventCol = eventCol,
    nStrata = 2,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )
 
# [1] "CD8_Res_Bulk--CD8_Exh_Bulk"     "CD4_Res_Bulk--NK_Exh_Bulk"     
# [3] "CD8_Exh_Bulk--NK_Res_Bulk"      "CD8_Res_Bulk--NK_Exh_Bulk"     
# [5] "CD4_Res_Bulk--CD8_Exh_Bulk"     "CD4_Res_Bulk--CD4_Exh_Bulk"    
# [7] "NK_Res_Bulk--NK_Exh_Bulk"       "CD8NK_Exh_Bulk--CD8NK_Res_Bulk"

cox_PFI_2Comb_Extremes_sig <-
  cox_PFI_2Comb_Extremes %>% filter(`Pr(>|z|)` <= 0.05) %>%
  data.frame(check.names = F)

cox_PFI_2Comb_Extremes_sig$VariableName 


# pdf(
#   paste0(figPath, "PFI_TCGA_ExtremeScorePairs_Cox.pdf"),
#   height = 5.8,
#   width = 6
# )

for (cc in cox_PFI_2Comb_Extremes_sig$VariableName) {
  annot <-
    wide2CombLongSel[wide2CombLongSel$Comb_Name == cc, ]

  annot[, timeCol] <- as.numeric(annot[, timeCol])
  annot[, eventCol] <- as.numeric(annot[, eventCol])

  fitValues <- survfit(Surv(time = annot[, timeCol],
                            event = annot[, eventCol]) ~
                         annot$Comb_2status)

  nSamples <- as.numeric(table(annot$Comb_2status)[1])
  pValCox <- cox_PFI_2Comb_Extremes_sig$`Pr(>|z|)`[cox_PFI_2Comb_Extremes_sig$VariableName == cc]

  if (pValCox < 0.01) {
    pValCox <- " < 0.01"
  } else {
    pValCox <- paste0(" = ", round(pValCox, 3))
  }

  print(survminer::ggsurvplot (
    fitValues,
    data = annot,
    fun = "pct",
    pval = T,
    conf.int = F,
    palette = cols,
    xlab = "Time",
    legend.title = "",
    title = "TCGA",
    subtitle = paste0("p-value (Cox)", pValCox, ";", " N = ", nSamples, " in each group"),
    # legend.labs = c("High CD4_Exh & Low NK_Exh", "Low CD4_Exh & High NK_Exh"),
    legend = c(.5, .2),
    font.x = 20,
    font.y = 20,
    font.tickslab = 18,
    font.main = 20,
    font.submain = c(17, "italic"),
    font.legend = 11

  ))

}
# dev.off()


write.csv(cox_PFI_2Comb_Extremes_sig, 
          paste0(outPath, "TCGA_Cox_PFI_ExtremeScorePairs_significant.csv"), 
          row.names = F)
```




# Mutations
The mutation file (maf) for colorectal cacner samples were downloaded using the TCGABiolink package. 
```{r}
# currentAnnot_ruv <- dList$currentAnnot_ruv

maf <- readRDS(paste0(tcgaPath, "DontPush/COAD_READ_maf.RDS"))

maf <- maf %>% 
  data.frame(check.rows = F, check.names = F)
dim(maf)
class(maf)

maf$patient <- sapply(maf$Tumor_Sample_Barcode, substr, 1, 12 )

## 394
length(intersect(maf$patient, currentAnnot_ruv$patient))


kpCols <- c(
  "patient",
    "Tumor_Sample_Barcode",
    "Hugo_Symbol",
    "Entrez_Gene_Id",
    "Variant_Classification",
    "IMPACT",
    "Variant_Type",
    "One_Consequence",
    "CANONICAL",
    "BIOTYPE"
  )

# dupGene <- mut %>%
#   group_by(Tumor_Sample_Barcode) %>%
#   mutate(dupGenes = sum(duplicated(Hugo_Symbol))) %>%
#   data.frame() 

mut <- maf[, kpCols] %>%
  ## Filter based on IMPACT
  filter(!IMPACT == "LOW" & !IMPACT == "MODIFIER") %>%
  group_by(Tumor_Sample_Barcode, Hugo_Symbol) %>%
  add_tally() %>%
  arrange(-n) %>%
  data.frame()  


mutUnique <- mut[! duplicated(mut[, c("Tumor_Sample_Barcode", "Hugo_Symbol")]) ,]
mutUnique$Variant_Types <- mutUnique$Variant_Type
mutUnique$Variant_Types[ mutUnique$n > 1] <- "MHT"

# library(tidyverse)

variants <-  mutUnique %>% 
  dplyr::select(Tumor_Sample_Barcode, Hugo_Symbol, Variant_Types) %>% 
  spread(key = Tumor_Sample_Barcode, value = Variant_Types) %>% 
  data.frame(check.names = F)

conseq <-  mutUnique %>% 
  dplyr::select(Tumor_Sample_Barcode, Hugo_Symbol, One_Consequence) %>% 
  spread(key = Tumor_Sample_Barcode, value = One_Consequence) %>% 
  data.frame(check.names = F)


gsymbols <- variants$Hugo_Symbol
variants <- as.matrix(variants[, -1])
row.names(variants) <- gsymbols

gsymbols <- conseq$Hugo_Symbol
conseq <- as.matrix(conseq[, -1])
row.names(conseq) <- gsymbols


varConsq <- matrix(paste(variants, conseq, sep = ";"), ncol = ncol(variants))
colnames(varConsq) <- colnames(conseq)
rownames(varConsq) <- rownames(conseq)

# saveRDS(varConsq, paste0(outPath, "VarConseq_TCGA_COAD.RDS"))

```

**Calculate mutational load**
```{r}
varConsqBin <- varConsq
varConsqBin[varConsqBin == "NA;NA"] <- 0
varConsqBin[varConsqBin != "0"] <- 1
varConsqBin <- apply(varConsqBin, 2, as.numeric)

row.names(varConsqBin) <- rownames(varConsq)

MutLoad <- colSums(varConsqBin)

MutLoadData <- data.frame(MutationLoad = MutLoad) %>% 
  mutate(barcode = rownames(.)) %>%
  mutate(Sample.ID = substr(barcode, 1, 16)) %>%
  data.frame()


colnames(varConsqBin) <- sapply(colnames(varConsqBin), function(x) substr(x, 1, 16))

```


**Generate long format of scoreAnnot**
```{r}
# scoreNames <- colnames(currentAnnot_ruv)[152:ncol(currentAnnot_ruv)]
scoreColumns <- which(colnames(currentAnnot_ruv) %in% scoreNames)

scoreAnnot <- pivot_longer(currentAnnot_ruv, 
                           cols = scoreColumns[1]:scoreColumns[length(scoreColumns)], 
                           values_to = "Score",
                           names_to = "Signature") %>% 
  data.frame()

```


## Build models based on mutations
To prepare the mutation data for later use, we convert the conseq data into long format and then merge it with annotation data.
```{r}
## currentAnnot does not have normal samples
## make a long format of the mut data

currentScore2 <- scoreAnnot %>% 
  dplyr::select(c(Sample.ID, Signature, Score)) %>% 
  ## Subset to interesting signatures:
  # filter(Signature %in% c(imSigs, canSigs)) %>% 
  filter(grepl("Bulk", Signature)) %>% 
  data.frame()
      

conseqLong2 <- data.frame(conseq, check.names = F) %>%
  ## save rownames as a column that has gene names
  mutate(gene_name = rownames(.)) %>%
  ## transform data into long format
  pivot_longer(.,
               cols = 1:(ncol(.) - 1),
               names_to = "Sample",
               values_to = "Mutation") %>%
    ## define dummy variable for mut
  mutate(Mut = ifelse(!is.na(Mutation), 1, 0)) %>% 
  ## add sample id to be used for merging later:
  mutate(Sample.ID = substr(Sample, 1, 16)) %>%
  ## Filter for genes with low mutations:
  group_by(gene_name) %>% 
  filter(sum(Mut) >= 10) %>% 
  ## merge with score data
  inner_join(x = ., y = currentScore2, by = "Sample.ID")


# saveRDS(conseqLong2, paste0(outPath, "TCGA_COAD_RUV_MutConseq_Long_Scores_highMutGenes_BulkSigs.RDS"))
# conseqLong2 <- readRDS(paste0(outPath, "TCGA_COAD_RUV_MutConseq_Long_Scores_highMutGenes_BulkSigs.RDS"))

```



### Linear models of Mutations 0/1 and Res/Exh scores
For each of the Res_Bulk and Exh_Bulk signatures from CD8, CD4, and NK cells, we build linera models with Scores as output and gene mutation (binary) as input. Then we perform BH correction on p-values and subset the data to significant genes.
```{r}
conseq_nested <- conseqLong2 %>% 
  group_by(gene_name, Signature) %>% 
  nest() 
  
```


```{r}
library(broom)

# scoreNames <- colnames(conseqLongFilt)[6:ncol(conseqLongFilt)]
fitModConseq <- function(df) {
  lm(formula = Score ~ Mut,
  # lm(formula = formula(paste(s, " ~ ", "Mut")),
    data = df)}

##--- the next two code commands take some time to run
conseq_model <- conseq_nested %>%
  mutate(lm_Conseq = map(data, fitModConseq))

conseq_model_glance <- conseq_model %>% 
  mutate(lmMut_glance = map(lm_Conseq, glance)) %>% 
  unnest(lmMut_glance)


##--- add adj pvals
conseq_model_adjPval <- conseq_model_glance %>% 
  mutate(adj.pval = p.adjust(p.value, method = "BH")) 

# saveRDS(conseq_model_adjPval, paste0(outPath, "TCGA_COAD_RUV_MutModel_BulkScores.RDS"))


## select specific columns and export the data frame
conseq_model_adjPvalCols <- conseq_model_adjPval %>% 
    dplyr::select(gene_name, Signature, adj.pval) %>% 
  data.frame(check.names = F)

# write.table(
#   conseq_model_adjPvalCols,
#   paste0(outPath, "TCGA_COAD_RUV_MutModel_BulkScores_Data.txt"),
#   row.names = F,
#   sep = "\t"
# )

sigMut <- conseq_model_adjPvalCols %>%
  filter(adj.pval < 0.01) %>%
  data.frame()


conseq_model_adjPvalCols <- read.table(
  paste0(
    outPath,
    "TCGA_COAD_RUV_MutModel_BulkScores_Data.txt"
  ),
  # "TCGA_COAD_RUV_MutModelScores_Data.txt"),
  header = T,
  sep = "\t"
)


# signifRes <- conseq_model_adjPvalCols[conseq_model_adjPvalCols$adj.pval < 0.01, ]
# write.table(
#   signifRes,
#   paste0(outPath, "TCGA_COAD_Mutations_Signatures_lm.txt"),
#   row.names = F,
#   sep = "\t"
# )
```

Subset data to genes that are significantly associated with any of the Res_Bulk and Exh_Bulk scores. This is related to Suppl Table 4.
```{r}
## filter for significant ones: 4475 genes
conseq_model_signif <- conseq_model_adjPval %>% 
  filter(adj.pval < 0.01)

# saveRDS(conseq_model_signif, paste0(outPath, "TCGA_COAD_RUV_MutModel_BulkScores_significant.RDS"))

# conseq_model_signif <- readRDS(paste0(outPath, "TCGA_COAD_RUV_MutModel_BulkScores_significant.RDS"))


conseq_model_signif <- conseq_model_signif[order(conseq_model_signif$adj.pval), ]

conseq_model_signifCols <- conseq_model_signif %>% 
  # filter(grepl("All", Signature)) %>% 
  dplyr::select(gene_name, Signature, adj.pval) %>% 
  data.frame(check.names = F)

conseq_model_signifCols$Genes <- paste0("_", conseq_model_signifCols$gene_name)

conseq_model_signifCols <- conseq_model_signifCols %>% 
  arrange(Signature, adj.pval) %>% 
  data.frame()

# write.table(
#   conseq_model_signifCols,
#   paste0(outPath, "TCGA_COAD_RUV_MutModel_BulkScores_significantData.txt"),
#   row.names = F,
#   sep = "\t"
# )
# 
# 
# conseq_model_signifCols <-
#   read.table(
#     paste0(
#       outPath,
#       "TCGA_COAD_RUV_MutModel_BulkScores_significantData.txt"
#     ),
#     header = T,
#     sep = "\t"
#   )

```


### GO of mutations assocaited with NK_Exh_Bulk scores
For the results of the mutation analysis related to NK_Exh_Bulk signature score, we perform GO enrichment analysis. In this section, we export the Suppl Table 5, and generate Suppl Figure 9.
```{r}
library(GO.db)
library(rrvgo)
library(org.Hs.eg.db)
library(annotate)

## 740 genes
# currentSymbols <-  unique(conseq_model_signif_AllExh$gene_name[conseq_model_signif_AllExh$adj.pval < 0.001])

# 209 genes
# currentSymbols <-  unique(conseq_model_signif_AllTrm$gene_name[conseq_model_signif_AllTrm$adj.pval < 0.001])

currentSymbols <-  unique(conseq_model_signifCols$gene_name[conseq_model_signifCols$Signature == "NK_Exh_Bulk" & conseq_model_signifCols$adj.pval < 0.0001])


currentIDs <-
  mapIds(org.Hs.eg.db,
         keys = currentSymbols,
         'ENTREZID',
         'SYMBOL')

currentIDs <- currentIDs[complete.cases(currentIDs)]

goExh <- limma::goana(currentIDs, FDR = 0.01, species = "Hs")
go_analysis <- limma::topGO(goExh, ontology = "BP", number = Inf)

go_analysis <- go_analysis[go_analysis$P.DE < 0.01, ]
# go_analysis <- go_analysis[go_analysis$P.DE < 0.0001, ]
 

go_analysis <- go_analysis[go_analysis$N > 20 & go_analysis$N < 1500, ]
# bp <- names(Ontology(GOTERM))[Ontology(GOTERM) == "BP"]
# # 29211 BP terms

simMatrix <- calculateSimMatrix(rownames(go_analysis),
                                orgdb = "org.Hs.eg.db",
                                ont = "BP",
                                method = "Rel")

scores <- setNames(-log10(go_analysis$P.DE), rownames(go_analysis))

reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold = 0.9,
                                orgdb = "org.Hs.eg.db")

# write.table(
#   go_analysis,
#   paste0(outPath, "GO_TCGA_NK_Exh_mutSig.0001_GO.01_th.8.txt"),
#   row.names = T,
#   sep = "\t"
# )

# pdf(
#   paste0(figPath, "GO_TCGA_Mut_NK_Exh_mutSig.0001_GO.01_th.8.pdf"),
#   height = 8,
#   width = 14
# )
heatmapPlot(
  simMatrix,
  reducedTerms,
  annotateParent = TRUE,
  annotationLabel = "parentTerm",
  fontsize = 10,
  fontsize_row = 1,
  fontsize_col = 1
)
# dev.off()


# pdf(
#   paste0(figPath, "GO_ScatterPlot_TreeMap_TCGA_Mut_NK_Exh_mutSig.0001_GO.01.pdf"),
#   height = 10,
#   width = 10
# )
# scatterPlot(simMatrix, reducedTerms)
# treemapPlot(reducedTerms)
# dev.off()
# rrvgo::shiny_rrvgo()
```


###  Boxplots of scores for selected genes
This reproduces Figure 5 in the paper, which includes boxplots of scores stratified by mutation status for selected genes:
"BRAF", "APC", "JAK1", "STAT1", "SPEN", "DNAH3". The code below exports several PDF files.
```{r}
selgenes <- c("BRAF", "APC", "JAK1", "STAT1", "SPEN", "DNAH3")

conseq_model_signif_ExhTrm <- conseq_model_signif %>%
  filter(!grepl("All", Signature)) %>%
  dplyr::select(gene_name, Signature, adj.pval) %>%
  data.frame(check.names = F)


selSigs <- unique(conseq_model_signif_ExhTrm$Signature)[
  order(unique(conseq_model_signif_ExhTrm$Signature))
]

mutSignif_selGenesImmune <- conseq_model_adjPval %>%
  filter(gene_name %in% selgenes &
           Signature %in% selSigs)


currentMutData <- mutSignif_selGenesImmune


currentMutData$gene_name <- as.character(currentMutData$gene_name) 

library(gridExtra)

for(i in selSigs) {
  ss <- currentMutData[currentMutData$Signature == i, ]
  
  p <- list()
  
  for (g in 1:nrow(ss)) {
    mm <- ss$lm_Conseq[[g]]
    
    p[[g]] <- augment(mm) %>%
      mutate(Mut = as.logical(Mut)) %>%
      ggplot(data = ., aes(x = Mut, y = Score, color = Mut)) +
      geom_boxplot() +
      geom_jitter(position = position_jitter(0.2), alpha = 0.4) +
      geom_signif(
        comparisons = list(c("FALSE", "TRUE")),
        map_signif_level = TRUE,
        tip_length = 0,
        vjust = 1.4,
        col = "gray40"
      ) +
      ggtitle(paste0(as.character(ss$gene_name[g]))) +
      scale_color_manual(values = brewer.pal(4, "Dark2")[c(1, 3)]) +
      scale_x_discrete(breaks = c("FALSE", "TRUE"),
                       labels = c("WT", "Mut")) +
      scale_y_continuous(
        breaks = equal_breaks(n = nBreak, s = scalingFactor),
        expand = c(scalingFactor, 0)
      ) +
      theme_bw() +
      theme(
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "none"
      )
    
  }
  names(p) <- ss$gene_name
  p <- p[selgenes]
  
  
  pdf(
    paste0(
      figPath,
      "Boxplot_TCGA_COAD_RUV_Mut_",
      i,
      "_Scores_selGenes.pdf"
    ),
    height = 2.5,
    width = 8
  )
  do.call(grid.aCrrange, c(p, ncol = 6))
  grid.arrange(grobs = p,
               ncol = 6
               # widths = c(1, 1, 1),
               # layout_matrix = rbind(c(1, 2, 3))
               )
               dev.off()
}

```

## Elastic Net regression
Here we perform Elastic Net Regression with NK scores as output and all the significant genes obtained above for the NK scores as well as a few clinical annotations as inputs. 
```{r}
currentAnnot_ruvSel <-
  currentAnnot_ruv[! currentAnnot_ruv$shortLetterCode == "NT" &
                   ! duplicated(currentAnnot_ruv$Sample.ID), c(
    "Sample.ID",
    "MSI_TCGAbiolink_annot",
    "CMS",
    "Stage",
    "NK_Exh_Bulk",
    "NK_Res_Bulk"
  )]

currentAnnot_ruvSel$MSI_TCGAbiolink_annot[currentAnnot_ruvSel$MSI_TCGAbiolink_annot == "Indeterminate"] <- NA

## remove samples with NA for clinical data
## 412 samples --> 351 samples
apply(currentAnnot_ruvSel, 2, function(x) sum(is.na(x)))

currentAnnot_ruvSel <- currentAnnot_ruvSel[complete.cases(currentAnnot_ruvSel), ]

## keep genes with mutations in >= 10 samples
mutPerGene <- colSums(t(varConsqBin) == 1)
kpGenes <- mutPerGene >= 10
# 7037 TRUE

gg <- names(mutPerGene[kpGenes])
varConsqBinData <-
  data.frame(t(varConsqBin)[, kpGenes],
             MutLoadData,
             check.names = F,
             check.rows = F)

## again we have gene mutated in less than 10 samples after merging the data:
varConsqBinDataClin <-
  merge(varConsqBinData,
        currentAnnot_ruvSel,
        by.x = "row.names",
        by.y = "Sample.ID")

mutPerGene <- colSums(varConsqBinDataClin[, gg])
## 3238 genes
rmGenes <- names(mutPerGene[mutPerGene < 10])

varConsqBinDataClin <- varConsqBinDataClin[,  !colnames(varConsqBinDataClin)  %in% rmGenes]
# 4772 genes --> 3238 genes

rownames(varConsqBinDataClin) <- varConsqBinDataClin$Sample.ID

# saveRDS(
#   varConsqBinDataClin,
#   paste0(outPath, "ExasticNetData_varConsqBinDataClin_TCGA.RDS")
# )

# varConsqBinDataClin <- readRDS(
#   paste0(outPath, "ExasticNetData_varConsqBinDataClin_TCGA.RDS")
# )


```

### Factors predictive of NK_Exh_Bulk scores
```{r}
## REMOVE columns we do not need:
dataGlmnet <- varConsqBinDataClin[, !colnames(varConsqBinDataClin) %in% c(
  "Row.names",
  "barcode",
  "Sample.ID",
  "MutationLoad_Groups",
  "site_of_resection_or_biopsy",
  "NK_Res_Bulk"
)]


model_formula <- as.formula("NK_Exh_Bulk ~ .")

X <- model.matrix(model_formula, 
                  data = dataGlmnet)[,
                                     -which(
  colnames(dataGlmnet) == "NK_Exh_Bulk")  ]

y <- dataGlmnet$NK_Exh_Bulk


##------ select lambdas
lambda_values <- 10^seq(-2, 10, length = 100)

cv_fit <- cv.glmnet(X, y, alpha = 0.5, lambda = lambda_values)

plot(cv_fit)
opt_lambda <- cv_fit$lambda.min
opt_lambda
##  0.0175 for Exh 


##------ I repeated with smaller lambad, and the resultant genes were very similar
lambda_values0 <- 10^seq(-2, 1, length = 100)

cv_fit0 <- cv.glmnet(X, y, alpha = 0.5, lambda = lambda_values0)

plot(cv_fit0)
opt_lambda0<- cv_fit0$lambda.min
opt_lambda0


##--------
model0 <- glmnet(X, y, alpha = 0.5, lambda = lambda_values)

# pdf(paste0(figPath, "TCGA_ElastiNet_NK_Exh_plots.pdf"), 
#     height = 5, width = 7)
plot(cv_fit)
plot(model0, xvar="lambda")
plot(model0, main="Elastic Net")
# dev.off()

##--------

model <- glmnet(X, y, alpha = 0.5, lambda = opt_lambda)

b <- as.matrix(model$beta)

b <- b[ b[,1] != 0, ]
b <- data.frame(beta = b)
b <- b[order(b, decreasing = T), , drop = F]


model0 <- glmnet(X, y, alpha = 0.5, lambda = opt_lambda0)

b0 <- as.matrix(model0$beta)

b0 <- b0[ b0[,1] != 0, ]
b0 <- data.frame(beta = b0)
b0 <- b0[order(b0, decreasing = T), , drop = F]

## 46 predictive variables for d, including two CMS3 and CMS4
## 43 for d0, and 42 are overlapping


# saveRDS(model, paste0(outPath, "TCGA_Models_NK_Exh_ElasticNet.RDS"))

# model <- readRDS(paste0(outPath, "TCGA_Models_NK_Trm_ElasticNet.RDS"))

# write.table(
#   b,
#   paste0(outPath, "TCGA_Models_NK_Exh_ElasticNet.txt"),
#   row.names = T,
#   sep = "\t"
# )

```

### Factors predictive of NK_Res_Bulk scores
```{r}
## REMOVE columns we do not need:
dataGlmnet <- varConsqBinDataClin[, !colnames(varConsqBinDataClin) %in% c(
  "Row.names",
  "barcode",
  "Sample.ID",
  "MutationLoad_Groups",
  "site_of_resection_or_biopsy",
  "NK_Exh_Bulk"
)]

model_formula <- as.formula("NK_Res_Bulk ~ .")

X <- model.matrix(model_formula, 
                  data = dataGlmnet)[,
                                     -which(
  colnames(dataGlmnet) == "NK_Res_Bulk")  ]

y <- dataGlmnet$NK_Res_Bulk



##------ select lambdas
lambda_values <- 10^seq(-2, 10, length = 100)

cv_fit <- cv.glmnet(X, y, alpha = 0.5, lambda = lambda_values)

plot(cv_fit)
opt_lambda <- cv_fit$lambda.min
opt_lambda  ##   0.0132 for Res 0.01


##------ if repeating with small lambad, then: min.lambda is the same 
lambda_values0 <- 10^seq(-2, 1, length = 100)

cv_fit0 <- cv.glmnet(X, y, alpha = 0.5, lambda = lambda_values0)

plot(cv_fit0)
opt_lambda0<- cv_fit0$lambda.min
opt_lambda0



model0 <- glmnet(X, y, alpha = 0.5, lambda = lambda_values)

# pdf(paste0(figPath, "TCGA_ElastiNet_NK_Res_plots.pdf"), 
#     height = 5, width = 7)
plot(cv_fit)
plot(model0, xvar="lambda")
plot(model0, main="Elastic Net")
# dev.off()

##--------
model <- glmnet(X, y, alpha = 0.5, lambda = opt_lambda)

b <- as.matrix(model$beta)

b <- b[ b[,1] != 0, ]
b <- data.frame(beta = b)
b <- b[order(b, decreasing = T), , drop = F]


model0 <- glmnet(X, y, alpha = 0.5, lambda = opt_lambda0)

b0 <- as.matrix(model0$beta)

b0 <- b0[ b0[,1] != 0, ]
b0 <- data.frame(beta = b0)
b0 <- b0[order(b0, decreasing = T), , drop = F]


# saveRDS(model, paste0(outPath, "TCGA_Models_NK_Res_ElasticNet.RDS"))
# 
# write.table(
#   b,
#   paste0(outPath, "TCGA_Models_NK_Res_ElasticNet.txt"),
#   row.names = T,
#   sep = "\t"
# )
```


```{r}
en_trm <- read.table(
  paste0(outPath, "TCGA_Models_NK_Res_ElasticNet.txt"),
  header = T,
  sep = "\t"
)
en_exh <- read.table(
  paste0(outPath, "TCGA_Models_NK_Exh_ElasticNet.txt"),
  header = T,
  sep = "\t"
)

com_EN <- intersect(row.names(en_exh), row.names(en_trm))
#  [1] "HTR5A"    "TUBGCP3"  "CMSCMS4"  "SMTN"     "BRAF"     "DCAF12L2"
#  [7] "INSM2"    "ARID2"    "ZNF543"   "RNF20"    "KIF26A"   "CPXM2"   
# [13] "APC"    

exhOnly_EN <- row.names(en_exh)[! row.names(en_exh) %in% row.names(en_trm)]
#  [1] "POLD1"   "JAK1"    "PKN3"    "PIK3R5"  "TGM6"   
#  [6] "NOVA1"   "SLC19A1" "VPS33A"  "TCHH"    "TRRAP"  
# [11] "TJP2"    "SASH1"   "DLGAP4"  "MACF1"   "`HLA-B`"
# [16] "ARID1A"  "JPH3"    "ARID1B"  "ROR2"    "PLEKHA6"
# [21] "SYNRG"   "CLCN4"   "USP5"    "EMILIN1" "DNAH3"  
# [26] "ZFHX4"   "CAMKK2"  "DNAH2"   "PLXNA1"  "MXRA5"  
# [31] "NOL4L"   "SRCIN1"  "CMSCMS3"

trmOnly_EN <- row.names(en_trm)[! row.names(en_trm) %in% row.names(en_exh)]
# [1] "HGF"       "SLC10A2"   "PAK4"      "TUBA3C"   
#  [5] "APBB1IP"   "ADGRA2"    "FRMD4A"    "SPATA31E1"
#  [9] "CYFIP2"    "SAP130"    "MROH7"     "DIAPH2"   
# [13] "MYH13"     "PCSK5"     "KCNA6"     "POLR3B"   
# [17] "MMP13"     "FAM21C"    "MST1R"     "CDON"     
# [21] "ANK3"      "NFRKB"     "TLR9"      "TGFBRAP1" 
# [25] "LAMB2"     "CADPS"     "PPARGC1B"  "SH3TC1"   
# [29] "MPDZ"      "TET1"      "KLC1"      "TMEM132D" 
# [33] "SGSM1"     "TET2"      "MYLK"      "PTK2B"    
# [37] "TFAP2D"    "ZYG11B"    "DDX54"     "ADGRG2"   
# [41] "LRP1"      "C8B"       "ZNF646"    "MYO9B"    
# [45] "GRIK3"     "NPHS1"     "NTM"       "C18orf8"  
# [49] "SHOX"      "IGSF9B"    "PXDN"      "TP53"     
# [53] "CEP350"    "EML1"      "TECPR2"    "APP"      
# [57] "OLFM1"     "SPAG17"    "OSR2"      "MYO5C"    
# [61] "DCBLD1"    "SNTG1"     "PCDHGB3"    
```

Export a table containing all the predictive variables for NK_Res_Bulk and NK_Exh_Bulk scores (Suppl Table 6). 

```{r}
enNK <-
  data.frame(
    predictors = unique(c(
      rownames(en_trm), 
      rownames(en_exh))))

enNK$Output[enNK$predictors  %in% rownames(en_trm)] <- "NK_Res"
enNK$Output[enNK$predictors  %in% rownames(en_exh)] <- "NK_Exh"
enNK$Output[enNK$predictors  %in% rownames(en_exh) &
             enNK$predictors  %in% rownames(en_trm) ] <- "Both"

enNK_beta <-
  merge(enNK,
        en_trm,
        by.x = "predictors",
        by.y = "row.names",
        all.x = T)
colnames(enNK_beta)[3] <- "beta_NK_Res"

enNK_beta <-
  merge(enNK_beta,
        en_exh,
        by.x = "predictors",
        by.y = "row.names",
        all.x = T)
colnames(enNK_beta)[4] <- "beta_NK_Exh"

enNK_beta$predictors[enNK_beta$predictors == "`HLA-B`"] <- "HLA-B"
enNK_beta$predictors[enNK_beta$predictors == "CMSCMS3"] <- "CMS3"
enNK_beta$predictors[enNK_beta$predictors == "CMSCMS4"] <- "CMS4"

# write.table(
#   enNK_beta,
#   paste0(outPath, "TCGA_ElasticNet_NK_ResExh_beta.txt"),
#   row.names = F,
#   sep = "\t"
# )


# enNK_beta <- read.table(paste0(outPath, "TCGA_ElasticNet_NK_ResExh_beta.txt"),
#                         header = T, sep = "\t")
```

### Boxplot of Elastic Net results
We generate boxplots of NK_Exh_Bulk and NK_Res_Bulk scores stratified by mutations status (Mut vs WT) for genes that are predictive of both signature scores (Suppl Figure 10), for genes that are predictive of only NK_Exh_Bulk scores (Suppl Table 11), and for those that are predictive of only NK_Res_Bulk scores (Suppl Table 12). 
```{r}
rmCols <- c(
  "Row.names",
  "MutationLoad",
  "barcode",
  "Sample.ID",
  "MSI_TCGAbiolink_annot",
  "CMS",
  "Stage"
)


dbox <- varConsqBinDataClin[, ! colnames(varConsqBinDataClin)  %in% rmCols]

dbox <- dbox[, colnames(dbox) %in% c(
  unique(enNK_beta$predictors),
  "NK_Exh_Bulk",
  "NK_Res_Bulk")]

dboxLong <- dbox %>% 
  rownames_to_column(var = "patient") %>% 
  pivot_longer(cols = 2:(ncol(dbox)-1), values_to = "Mut", names_to = "Genes") %>% 
  data.frame(check.names = F)

dboxLong$Mut[dboxLong$Mut == 1] <- "Mut"
dboxLong$Mut[dboxLong$Mut == 0] <- "WT"

dboxLong$Mut <- factor(dboxLong$Mut, levels = c("WT", "Mut"))

```


#### Genes predictive of bothe signature scores
```{r, fig.height = 7, fig.width = 10}
p1 <- dboxLong %>%
  filter(Genes %in% intersect(row.names(en_exh), row.names(en_trm))) %>%
  # mutate(Mut = as.logical(Mut)) %>%
  ggplot(data = ., aes(x = Mut, y = NK_Exh_Bulk, color = Mut)) +
  geom_boxplot() +
  geom_jitter(position = position_jitter(0.2), alpha = 0.4) +
  facet_wrap( ~ Genes) +
  ggpubr::geom_signif(
    comparisons = list(c("Mut", "WT")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  scale_color_manual(values = brewer.pal(4, "Dark2")[c(1, 3)]) +
  scale_x_discrete(breaks = c("FALSE", "TRUE"),
                   labels = c("WT", "Mut")) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  currentTheme +
  theme(
     axis.title.x = element_blank())


p2 <- dboxLong %>%
  filter(Genes %in% intersect(row.names(en_exh), row.names(en_trm))) %>%
  # mutate(Mut = as.logical(Mut)) %>%
  ggplot(data = ., aes(x = Mut, y = NK_Res_Bulk, color = Mut)) +
  geom_boxplot() +
  geom_jitter(position = position_jitter(0.2), alpha = 0.4) +
  facet_wrap( ~ Genes) +
  ggpubr::geom_signif(
    comparisons = list(c("Mut", "WT")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  scale_color_manual(values = brewer.pal(4, "Dark2")[c(1, 3)]) +
  scale_x_discrete(breaks = c("FALSE", "TRUE"),
                   labels = c("WT", "Mut")) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  currentTheme +
  theme(
     axis.title.x = element_blank())


library(gridExtra)

# pdf(paste0(figPath,
#            "Boxplot_TCGA_Mut_ElasticNet_SignifComNKResExh.pdf"), 
#     height = 7, width = 10
#     )

grid.arrange(
  grobs = list(p1, p2),
  ncol = 2
)

dev.ofCf()

```


#### Genes predictive of NK_Exh_Bulk only
```{r, fig.height = 9, fig.width=10}
p <- dboxLong %>%
  filter(Genes %in% 
           c(row.names(en_exh)[! row.names(en_exh) %in% row.names(en_trm)], "HLA-B")) %>%
  # mutate(Mut = as.logical(Mut)) %>%
  ggplot(data = ., aes(x = Mut, y = NK_Exh_Bulk, color = Mut)) +
  geom_boxplot() +
  geom_jitter(position = position_jitter(0.2), alpha = 0.4) +
  facet_wrap( ~ Genes, ncol = 8) +
  ggpubr::geom_signif(
    comparisons = list(c("Mut", "WT")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  scale_color_manual(values = brewer.pal(4, "Dark2")[c(1, 3)]) +
  scale_x_discrete(breaks = c("FALSE", "TRUE"),
                   labels = c("WT", "Mut")) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  currentTheme +
  theme(
     axis.title.x = element_blank())

# pdf(
#   paste0(figPath,
#          "Boxplot_TCGA_Mut_ElasticNet_SignifOnlyNKExh.pdf"),
#   height = 9,
#   width = 10
# )
p
# dev.off()

```

#### Genes predictive of NK_Res_Bulk only
```{r}
p <- dboxLong %>%
  filter(Genes %in% 
           row.names(en_trm)[! row.names(en_trm) %in% row.names(en_exh)]) %>%
  # mutate(Mut = as.logical(Mut)) %>%
  ggplot(data = ., aes(x = Mut, y = NK_Res_Bulk, color = Mut)) +
  geom_boxplot() +
  geom_jitter(position = position_jitter(0.2), alpha = 0.4) +
  facet_wrap( ~ Genes, ncol = 9) +
  ggpubr::geom_signif(
    comparisons = list(c("Mut", "WT")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  scale_color_manual(values = brewer.pal(4, "Dark2")[c(1, 3)]) +
  scale_x_discrete(breaks = c("FALSE", "TRUE"),
                   labels = c("WT", "Mut")) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  currentTheme +
  theme(
     axis.title.x = element_blank())

# pdf(
#   paste0(figPath,
#          "Boxplot_TCGA_Mut_ElasticNet_SignifOnlyNKRes.pdf"),
#   height = 13,
#   width = 10
# )
p
# dev.off()
```


# Session information
Here are the list of tools and packages (along with their versions) used in this document. 
```{r}
sessionInfo()
```

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 598px;"></div>









