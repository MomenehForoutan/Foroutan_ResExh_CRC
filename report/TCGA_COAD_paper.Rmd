---
title: 'Survival and mutation analyses of the TCGA COAD data based on the Res and Exh scores'
author: 
  - name: 'Momeneh (Sepideh) Foroutan and Ramyar Molania'
    affiliation: 'Huntington Cancer Immunotherapy Lab'
    url: https://www.monash.edu/discovery-institute/huntington-lab
date: '12-06-2020'
output:
  rmdformats::readthedown:
    fig_width: 12
    fig_height: 6
    gallery: TRUE
    highlight: tango
    lightbox: TRUE
    self_contained: TRUE
    thumbnails: FALSE
    number_sections: TRUE	
    toc_depth: 4
    use_bookdown: TRUE
    code_folding: hide
  html_document2:
    df_print: paged
params:
  update_date: !r paste("Last updated on:", Sys.Date() )
editor_options: 
  chunk_output_type: inline
---
`r params$update_date`

<style>
body {
text-align: justify}
</style>

# Set up and overview
In this document, we read the corrected TCGA COAD data (using the RUV-III method), perform CMS clustering, and visualise the associations between Res_bulk and Exh_bulk scores and different sample annotations. We then perform survival analysis to examine the association of the scores with survival outcomes, and finish the analysis by performing mutation analysis to find genes whose mutations are predictive of Res or Exh in cancer samples.
```{r file set up, echo=F, results=F, message=F, warning=F}
mainDir <- getwd()
outPath <- "../output/TCGA/"
figPath <- "../figure/TCGA/"
dataPath <- "../data/"
scriptPath <- "../script/"

## to read gene length data
tcgaPath <-  "../data/TCGA/"

ifelse(!dir.exists(file.path(mainDir, outPath)), dir.create(file.path(mainDir, outPath)), FALSE)
ifelse(!dir.exists(file.path(mainDir, figPath)), dir.create(file.path(mainDir, figPath)), FALSE)
ifelse(!dir.exists(file.path(mainDir, dataPath)), dir.create(file.path(mainDir, dataPath)), FALSE)
ifelse(!dir.exists(file.path(mainDir, scriptPath)), dir.create(file.path(mainDir, scriptPath)), FALSE)

# library(ggplot2)
library(tidyverse)
library(RColorBrewer)
library(ggbeeswarm)
library(SingleCellExperiment)
library(Seurat)

options(digits = 3)

equal_breaks <- function(n = nBreak, s = scalingFactor, ...){
  function(x){
    # rescaling
    d <- s * diff(range(x)) / (1+2*s)
    round( seq(min(x)+d, max(x)-d, length=n), 2)
  }
}

nBreak = 3
scalingFactor = 0.05

textSize <- 1.2

currentTheme <- theme_bw() +
  theme(
    # panel.background = element_blank()
    axis.title = element_text(size = rel(textSize)),
    axis.text = element_text(angle = 0, size = rel(textSize)),
    # strip.background = element_rect(colour = "#f0f0f0", fill = "#f0f0f0"),
    strip.text = element_text(size = rel(textSize)),
    axis.line = element_line(colour = "black", size = 0.5),
    legend.position = 'top',
    legend.title = element_text(size = rel(textSize), face = "italic"),
    legend.text = element_text(size = rel(textSize)),
    legend.key.size = unit(1, 'lines'),
    ## increase the line space
    plot.title = element_text(
      face = "plain",
      size = rel(textSize),
      hjust = 0.5
    )
  )

cols <-  c(
  brewer.pal(8, "Dark2")[-5],
  brewer.pal(10, "Paired"),
  brewer.pal(12, "Set3"),
  brewer.pal(9, "Blues")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "Oranges")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "Greens")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "Purples")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "Reds")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "Greys")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "BuGn")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "PuRd")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "BuPu")[c(8, 3, 7, 4, 6, 9, 5)],
  brewer.pal(9, "YlGn")[c(8, 3, 7, 4, 6, 9, 5)])

# source(paste0(FreqScriptPath, "analysis/calcFiltFPKM_TCGA.R"))

source(paste0(scriptPath, "coxph_analysis.R"))
source(paste0(scriptPath,"survival_plot.R"))
```

## Read signatures
We read Res and Exh signatures that we obtained and focus on the genes that are not highly expressed in cancer cells (those that passed the bulk cancer threshold). Additionally, we defined two other types of signatures for eacj of the Exh and Res signatures: All_Res[Exh]_Bulk and CD8NK_Res[Exh]_Bulk by merging all Res[Exh]_Bulk signature genes and by merging only the CD8_Res[Exh]_Bulk and NK_Res[Exh]_Bulk. 
We also read several cancer related signatures as well as a few other immune related signatures collected from the literature as well as MSigDB. Here are the list of the signatures that we used in this document.
```{r}
source(paste0(scriptPath, "ReadSignaturesTum_paper.R"))
names(AllSigsCollection)
```

# Corrected TCGA
We have made an annotation file for the TCGA COAD by combining several annotation data from different sources to include as much info as possible for the samples; these include the [survival data from GDC](https://gdc.cancer.gov/about-data/publications/pancanatlas), the annotation file for the COAD downloaded using the TCGAbiolink package, as well as several columns associated with batch information.

We have also corrected the TCGA COAD data using the RUV-III method as suggested by [Molania et al](https://academic.oup.com/nar/article/47/12/6073/5494770?login=true). Here we read the data and annotation, and subset to the common samples.
```{r}
annot_merged <- readRDS(paste0(tcgaPath, "Annotation_COAD_Merged_InclNormal.RDS"))
currentAnnot_ruv <- annot_merged
```

```{r}
ruvTCGA <- readRDS(paste0(tcgaPath, "DontPush/TCGA_COAD_RUVadjusted_k19_PrpsPerPlateMsiCmsNormalNsample3.rds"))
 
## 479 common samples incl normal
comSamples <- intersect(rownames(currentAnnot_ruv), colnames(ruvTCGA))

ruvTCGA <- ruvTCGA[, comSamples]
currentAnnot_ruv <- currentAnnot_ruv[comSamples, ]
```


## CMS 
Perform CMS clustering only on Cancer samples, and add this to the annotation data.
```{r}
# devtools::install_github("Lothelab/CMScaller")
set.seed(20201011)

ruvTCGA_tum <- ruvTCGA[, currentAnnot_ruv$shortLetterCode != "NT"]
currentAnnot_ruvTum <- currentAnnot_ruv[colnames(ruvTCGA_tum), ]
  
  
cmsTCGA_ruv <-
  CMScaller::CMScaller(
    emat = ruvTCGA_tum,
    RNAseq = F,
    FDR = 0.05,
    rowNames = "symbol"
  )

currentAnnot_ruv <-
  merge(
    currentAnnot_ruv,
    cmsTCGA_ruv[, "prediction", drop = F],
    by.x = "barcode",
    by.y = "row.names",
    all.x = T
  )

colnames(currentAnnot_ruv)[colnames(currentAnnot_ruv) == "prediction"] <- "CMS"
currentAnnot_ruv$CMS <- as.character(currentAnnot_ruv$CMS)

currentAnnot_ruv$CMS[currentAnnot_ruv$shortLetterCode == "NT"] <- "N"

## removing normal
# CMS1 CMS2 CMS3 CMS4 <NA> 
#   74  129   68  138   30 

row.names(currentAnnot_ruv) <- currentAnnot_ruv$barcode
currentAnnot_ruv <- currentAnnot_ruv[colnames(ruvTCGA), ]

```

## Score corrected TCGA data

AllSigsCollection is a genesetcollection generated in ReadSignatureTum_paper.R script. We score samples against signatures and add the scores to the annotation data.
```{r}


library(singscore)

rd_TCGA_ruv <- rankGenes(ruvTCGA)

tcgaScoresDisp_ruv <- multiScore(rd_TCGA_ruv, 
                         upSetColc = AllSigsCollection, 
                         knownDirection = T, 
                         centerScore = F)

tcgaScores_ruv <-
  data.frame(t(tcgaScoresDisp_ruv$Scores),
             check.rows = F,
             check.names = F)

## Add TGFb-EMT bidirectional scores too:
tcgaScores_ruv$TGFbEMT_Dir <- simpleScore(
  rd_TCGA_ruv,
  upSet = sigsTum$TGFb_EMT$tgfb_Up,
  downSet = sigsTum$TGFb_EMT$tgfb_Dn,
  knownDirection = T,
  centerScore = F
)$TotalScore


# colnames(tcgaScores_ruv) <- gsub("Trm_", "Res_", colnames(tcgaScores_ruv))
scoreNames <- c(colnames(tcgaScores_ruv))
scoreNames <- scoreNames[order(scoreNames)]


##----- Add these to annotation data:
currentAnnot_ruv <-
  data.frame(currentAnnot_ruv ,
             tcgaScores_ruv,
             check.names = F,
             check.rows = F)
```


## Score for Cibersort 
We also score for general immune and stroma signatures
```{r}
source(paste0(scriptPath, "ReadSignatures_Cibersort_TCGA.R"))
# library(singscore)
# rd_TCGA_ruv <- rankGenes(ruvTCGA)

tcgaScoresDisp_ruv_imm <- multiScore(rd_TCGA_ruv, 
                         upSetColc = ImmSigsCollection, 
                         knownDirection = T, 
                         centerScore = F)

tcgaScores_ruv_imm <-
  data.frame(t(tcgaScoresDisp_ruv_imm$Scores),
             check.rows = F,
             check.names = F)



##----- Add these to annotation data:
currentAnnot_ruv_imm <-
  data.frame(currentAnnot_ruv ,
             tcgaScores_ruv_imm,
             check.names = F,
             check.rows = F)
```


# Save data after scores
```{r}

# saveRDS(list(ruvTCGA = ruvTCGA, currentAnnot_ruv = currentAnnot_ruv_imm),
#         paste0(outPath, "ruvTCGA_Annot.RDS"))
# tcga <- readRDS(paste0(outPath, "ruvTCGA_Annot.RDS"))
# 
# currentAnnot_ruv <- tcga$currentAnnot_ruv
# ruvTCGA <- tcga$ruvTCGA

ruvTCGA_tum <- ruvTCGA[, currentAnnot_ruv$shortLetterCode != "NT"]
currentAnnot_ruvTum <- currentAnnot_ruv[colnames(ruvTCGA_tum), ]
```

```{r}

cibAnnot_bulk <-
  currentAnnot_ruv_imm[, (grepl("Bulk", colnames(currentAnnot_ruv_imm)) &
                            !grepl("All_|CD8NK_", colnames(currentAnnot_ruv_imm))) |
                         colnames(currentAnnot_ruv_imm) %in% cibeNames]

cibAnnot_bulkLong <-
  pivot_longer(
    cibAnnot_bulk,
    cols = 7:30,
    names_to = "CIBERSORT_signatures",
    values_to = "CIBERSORT_scores"
  ) %>% 
  data.frame()

cibAnnot_bulkLong2 <- cibAnnot_bulkLong %>%
  pivot_longer(cols = 1:6,
               names_to = "ResExh_signatures",
               values_to = "ResExh_scores") %>% 
  data.frame()


pdf(
  paste0(figPath, "Scatterplot_TCGA_COBERSORT_ImmuneStroma_ResExh_Scores_Str_scaleFree.pdf"),
  # paste0(figPath, "Scatterplot_TCGA_COBERSORT_ResExh_Scores_Str.pdf"),
  height = 7,
  # width = 9
  width = 12
)
sigsResExh <- unique(cibAnnot_bulkLong2$ResExh_signatures)[
  order(unique(cibAnnot_bulkLong2$ResExh_signatures))
]
for(i in sigsResExh) {
  print(
    cibAnnot_bulkLong2 %>%
    filter(cibAnnot_bulkLong2$ResExh_signatures == i) %>%
    ggplot(., aes(ResExh_scores, CIBERSORT_scores)) +
    geom_point(color = "gray40", alpha = 0.5, size = 0.5) +
    # facet_wrap(~ CIBERSORT_signatures, ncol = 5) +
    facet_wrap(~ CIBERSORT_signatures, ncol = 6, scales = "free") +
    ggpubr::stat_cor(method = "spearman") +
    ggtitle(i) +
    theme_bw()
  )
}
dev.off()
```

We also generate a heatmap of the correlation values between Res/Exh scores and several immune signature scores from CIBERSORT. This generates Figure S14 - left panel.
```{r}

corData <- data.frame(matrix(nrow = 24, ncol = 0))
rownames(corData) <- cibeNames

imSigs_sub <- c(
  "CD4_Exh_Bulk",
  "CD4_Res_Bulk",
  "CD8_Exh_Bulk",
  "CD8_Res_Bulk",
  "NK_Exh_Bulk",
  "NK_Res_Bulk"
) 

for (im in imSigs_sub) {
      corValues <- vector()
      
  for (se in cibeNames) {
    
    corVal <- round(cor.test(currentAnnot_ruvTum[, im],
                             currentAnnot_ruvTum[, se])[[4]],
                    2)
    names(corVal) <- se
    corValues <- c(corValues, corVal)
    dd <- data.frame(corValues)
  }
  
  corData <- cbind(corData, dd)
}

# colnames(corData) <- selCanSigs
colnames(corData) <- imSigs_sub

library(circlize)
library(grid)

png(
  paste0(figPath, "Correlation_ResExh_CIBERSORT_noClust.png"),
  height = 8.5,
  width = 6,
  res = 400,
  units = "in"
)
ComplexHeatmap::Heatmap(
  corData,
  # cluster_columns = T,
  cluster_columns = F,
  cluster_rows = F,
  col = viridis::viridis(100),
  column_title = "Correlation of Res and Exh scores\nwith CIBERSORT signature scores\nin TCGA COAD data",
  cell_fun = function(j, i, x, y, width, height, fill) {
    grid.text(sprintf("%.2f", corData[i, j]), x, y, gp = gpar(fontsize = 10))
  }, show_heatmap_legend = T, name = "Pearson's\ncorrelation\ncoefficient\n"
)
dev.off()

```

## Scatterplots of score pairs
Generate scatterplots of scores vs each other. Uncomment the commented sections to change the colour the data points based on CMS or MSI. The below codes generate many scatterplots comparing each signature with all other signatures amongs immune signatures as well as across immune and cancer signatures.

```{r}

cmsCol <- c(
  brewer.pal(11, "BrBG")[3],
  brewer.pal(11, "PRGn")[2],
  brewer.pal(9, "Blues")[5],
  brewer.pal(11, "BrBG")[10]
)

pdf(
  paste0(
    figPath,
    "ScatterPlots_TCGA_ExhResScorePairs_colCMS_rmNormal_Lines.pdf"
    # "ScatterPlots_TCGA_ExhResScorePairs_colMSI_rmNormal_Lines.pdf"
  ),
  height = 4.7,
  width = 4.3
)

for(im in imSigs) {
  Others <- imSigs[imSigs != im]

  for (ot in Others) {

    d <- currentAnnot_ruv %>%
      mutate(MSI = MSI_TCGAbiolink_annot) %>%
      filter(! MSI  %in% "Indeterminate") %>%
      filter(! CMS  %in% "N") %>%
      mutate(medIm = median(!!sym(im)),
             medOt = median(!!sym(ot)))

    corVal <- round(
      cor.test(d[, im], d[, ot])[[4]], 2)


    palette <- cmsCol
    # palette <- rev(c(brewer.pal(9, "Purples") [c(4, 6, 9)]))

    pal <- list(values=palette, na.value="gray80")

    print(
      d %>%
        ggplot(.,
               aes_string(im, ot, color = "CMS")) +
               # aes_string(im, ot, color = "MSI")) +
        geom_point(alpha = 0.8) +
        invoke(scale_colour_manual, pal) +
        geom_vline(xintercept = d$medIm) +
        geom_hline(yintercept = d$medOt) +
        scale_x_continuous(
                       breaks = equal_breaks(n = nBreak, s = scalingFactor),
                       expand = c(scalingFactor, 0)
                     ) +
        scale_y_continuous(
                       breaks = equal_breaks(n = nBreak, s = scalingFactor),
                       expand = c(scalingFactor, 0)
                     ) +
        ggtitle(paste0("TCGA (cor = ", corVal, ")")) +
        currentTheme +
        guides(color = guide_legend(nrow=2))
    )
  }
}

dev.off()





pdf(
  paste0(
    figPath,
    "ScatterPlots_TCGA_ImmunAllCancerScorePairs_colCMS_rmNormal_Lines.pdf"
    # "ScatterPlots_TCGA_ImmunCancerScorePairs_colMSI_rmNormal_Lines.pdf"
  ),
  height = 4.7,
  width = 4.3
)

for(im in imSigs[!grepl("All", imSigs)]) {

  for (ca in canSigs) {

    d <- currentAnnot_ruv %>%
      mutate(MSI = MSI_TCGAbiolink_annot) %>%
      filter(! MSI  %in% "Indeterminate") %>%
      filter(! CMS  %in% "N") %>%
      mutate(medIm = median(!!sym(im)),
             medOt = median(!!sym(ca)))

    corVal <- round(
      cor.test(d[, im], d[, ca])[[4]], 2)


    palette <- cmsCol
    # palette <- rev(c(brewer.pal(9, "Purples") [c(4, 6, 9)]))

    pal <- list(values=palette, na.value="gray80")

    print(
      d %>%
        ggplot(.,
               aes_string(im, ca, color = "CMS")) +
               # aes_string(im, ca, color = "MSI")) +
        geom_point(alpha = 0.8) +
        invoke(scale_colour_manual, pal) +
        geom_vline(xintercept = d$medIm) +
        geom_hline(yintercept = d$medOt) +
        scale_x_continuous(
                       breaks = equal_breaks(n = nBreak, s = scalingFactor),
                       expand = c(scalingFactor, 0)
                     ) +
        scale_y_continuous(
                       breaks = equal_breaks(n = nBreak, s = scalingFactor),
                       expand = c(scalingFactor, 0)
                     ) +
        ggtitle(paste0("TCGA (cor = ", corVal, ")")) +
        currentTheme +
        guides(color = guide_legend(nrow=2))
    )
  }
}

dev.off()

```
We also generate a heatmap of the correlation values between Res/Exh scores and several selected signature scores. 
```{r}

corData <- data.frame(matrix(nrow = 8, ncol = 0))
rownames(corData) <- imSigs[!grepl("All", imSigs)]

# selCanSigs <-
#   c(
#     "TGFb_Signaling",
#     "TP53_signaling",
#     "OXPHOS",
#     "Peroxisome",
#     "HPX_EGF_EMT",
#     "TGFbEMT",
#     "DDR",
#     "DNA_Repair"
#   )

# for(se in selCanSigs) {
for(se in canSigs) {
  corValues <- vector()
  for (im in imSigs[!grepl("All", imSigs)]) {
    d <- currentAnnot_ruv %>%
      mutate(MSI = MSI_TCGAbiolink_annot) %>%
      filter(!MSI  %in% "Indeterminate") %>%
      filter(!CMS  %in% "N")
    
    corVal <- round(cor.test(d[, im], d[, se])[[4]], 2)
    names(corVal) <- im
    corValues <- c(corValues, corVal)
    dd <- data.frame(corValues)
  }
  
  corData <- cbind(corData, dd)
}

# colnames(corData) <- selCanSigs
colnames(corData) <- canSigs

library(circlize)
library(grid)

png(
  paste0(figPath, "Correlation_ResExh_AllCanSigs.png"),
  height = 5,
  width = 10,
  res = 400,
  units = "in"
)
ComplexHeatmap::Heatmap(
  corData,
  cluster_columns = T,
  cluster_rows = F,
  col = viridis::cividis(100),
  column_title = "Correlation of Res and Exh scores with \ndifferent signature scores in TCGA COAD data",
  cell_fun = function(j, i, x, y, width, height, fill) {
    grid.text(sprintf("%.2f", corData[i, j]), x, y, gp = gpar(fontsize = 10))
  }, show_heatmap_legend = T, name = "Pearson's\ncorrelation\ncoefficient\n"
)
dev.off()

```

## Scores vs Annotation

### Define Cancer and Immune signatures
```{r}
## 28 mostly cancer related  signatures
canSigs <- scoreNames[! grepl("Res_", scoreNames) &
                        ! grepl("Exh_", scoreNames)]

## our Res/Exh signatures
imSigs <- scoreNames[grepl("Res_", scoreNames) |
                        grepl("Exh_", scoreNames)]
 
```

### Boxplots stratified by MSI, CMS and tumour location
These reproduces Figure 4A and 4B (left panels) and Suppl Figure 13 (left panel). 
```{r, fig.height = 5, fig.width = 6}
library(ggsignif)

scoreColumns <- which(colnames(currentAnnot_ruv)  %in% scoreNames)

annTCGALong_ruv <- currentAnnot_ruv %>%
  pivot_longer(
    cols = scoreColumns[1]:scoreColumns[length(scoreColumns)],
    names_to = "Signature",
    values_to = "Score"
  ) %>%
  data.frame(check.rows = F, check.names = F)



pdf(
  paste0(figPath, "TCGA_Boxplot_Scores_MSI_Bulk.pdf"),
  height = 6,
  width = 5.2
)

annTCGALong_ruv %>%
  filter(MSI_TCGAbiolink_annot != "Indeterminate") %>% 
  filter(shortLetterCode != "N") %>%
  filter(grepl("Bulk", Signature)) %>%
  filter(! grepl("CD8NK", Signature) & ! grepl("All", Signature)) %>%
  mutate(MSI = MSI_TCGAbiolink_annot) %>% 
  ggplot(., aes(x = MSI, y = Score, color = MSI)) +
  geom_boxplot() +
  geom_signif(
    comparisons = list(c("MSI-H", "MSS")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  facet_wrap( ~ Signature, scales = "free", ncol = 2) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  scale_color_manual(values =  rev(c(brewer.pal(9, "Purples") [c(4, 6, 9)]))) +
  currentTheme +
    theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
        axis.ticks = element_blank(),
    legend.position = "bottom"
    )
dev.off()



cmsCol <- c(
  brewer.pal(11, "BrBG")[3],
  brewer.pal(11, "PRGn")[2],
  brewer.pal(9, "Blues")[5],
  brewer.pal(11, "BrBG")[10],
  "grey50"
)


pdf(
  paste0(figPath, "TCGA_Boxplot_Scores_CMS_Bulk.pdf"),
  height = 6,
  width = 5.5
)
library(ggpubr)

annTCGALong_ruv %>%
  filter(complete.cases(CMS)) %>%
  filter(grepl("Bulk", Signature)) %>%
  filter(! grepl("CD8NK", Signature) & ! grepl("All", Signature)) %>%
  ggplot(., aes(x = CMS, y = Score, color = CMS)) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap( ~ Signature, scales = "free", ncol = 2) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  scale_color_manual(values = cmsCol) +
  # stat_compare_means(comparisons = my_comparisons) + # Add pairwise comparisons p-value
  # stat_compare_means(label.y = 0.85) +     # Add global p-value
  currentTheme +
  theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
        axis.ticks = element_blank(),
    legend.position = "bottom"
    )

dev.off()


##---- Location
## better to use this: site_of_resection_or_biopsy rather than this: tissue_or_organ_of_origin; These are lists: primary_site and disease_type

# Right - proximal : caecum, asc. colon, hepatic flexure, transverse colon
# Left : Splenic Flexure, Desc Colon, Sigmoid, Rectosigmoid Junction 

rightTum <- c("Cecum", 
              "Ascending colon", 
              "Hepatic flexure of colon",
              "Transverse colon")

leftTum <- c("Sigmoid colon", 
              "Descending colon", 
              "Splenic flexure of colon",
              "Rectosigmoid junction")



annTCGALong_ruv$site_of_resection_or_biopsy[
  annTCGALong_ruv$site_of_resection_or_biopsy %in% rightTum
] <- "Proximal"

annTCGALong_ruv$site_of_resection_or_biopsy[
  annTCGALong_ruv$site_of_resection_or_biopsy %in% leftTum
] <- "Distal"
# 
pdf(
  paste0(figPath, "TCGA_Boxplot_Scores_Location_Bulk.pdf"),
  height = 6,
  width = 5
)
annTCGALong_ruv %>%
  filter(complete.cases(site_of_resection_or_biopsy)) %>%
  filter(grepl("Bulk", Signature)) %>%
  filter(! grepl("Colon, NOS", site_of_resection_or_biopsy)) %>%
  filter(! grepl("CD8NK", Signature) & ! grepl("All", Signature)) %>%
  ggplot(., aes(x = site_of_resection_or_biopsy, y = Score, color = site_of_resection_or_biopsy)) +
  geom_boxplot(outlier.shape = NA) +
  ggpubr::geom_signif(
    comparisons = list(c("Distal", "Proximal")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  facet_wrap( ~ Signature, scales = "free", ncol = 2) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  # scale_color_manual(values = c(brewer.pal(9, "Blues") [c(4, 5, 7, 9)], "gray50")) +
  scale_color_manual(values = brewer.pal(8, "Greys")[c(5, 7)]) +
  currentTheme +
  theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
        axis.ticks = element_blank(),
    legend.position = "bottom"
    )
  # theme_bw() 

dev.off()
```


#### p-values for the scores vs subtypes
```{r}

my_comparisons <- list(c("CMS1", "CMS2"), 
                       c("CMS1", "CMS3"), 
                       c("CMS1", "CMS4"),
                       c("CMS1", "N"),
                       c("CMS2", "CMS3"),
                       c("CMS2", "CMS4"),
                       c("CMS2", "N"),
                       c("CMS3", "CMS4"),
                       c("CMS3", "N"),
                       c("CMS4", "N")
                       )


dd <- annTCGALong_ruv %>%
  filter(complete.cases(CMS)) %>%
  filter(grepl("Bulk", Signature)) %>%
  filter(! grepl("CD8NK", Signature) & ! grepl("All", Signature)) %>%
  dplyr::select(CMS, Signature, Score) %>% 
  data.frame()
  

signatureNames <- unique(dd$Signature)


ll <- sapply(signatureNames, function(y) {
  d <- dd %>%
    filter(Signature == y) %>%
    data.frame()
  
  sapply(my_comparisons, function(x) {
    comp1 <- x[1]
    comp2 <- x[2]
    
    d <- d %>%
      filter(CMS == comp1 | CMS == comp2) %>%
      data.frame()
    
    res <-
      wilcox.test(d$Score[d$CMS == comp1], d$Score[d$CMS == comp2])$p.value
    return(res)
    
  })
})

row.names(ll) <- sapply(my_comparisons, function(x) paste(x[1], x[2], sep ="_"))


## replace non-significant items with NA
ll[ll > 0.05] <- NA


tiff(
  paste0(figPath, "CMS_pvals_TCGA.tiff"),
  height = 3.3,
  width = 5,
  units = "in",
  res = 300
)
ComplexHeatmap::Heatmap(t(ll), 
                        col = viridis::viridis(200), 
                        name = "p-value\n", 
                        cluster_rows = F, 
                        cluster_columns = F, 
                        column_title = "TCGA\n Wilcox test p-values")
dev.off()

```



# OS 
```{r}
library(survival)
timeCol = "OS.time"
eventCol = "OS"

annFilt <- currentAnnot_ruv[currentAnnot_ruv$shortLetterCode != "NT", ]

medAge <- median(as.numeric(annFilt$Age), na.rm = T)

annFilt$Age_status <- NA
annFilt$Age_status[annFilt$Age < medAge] <- "Young"
annFilt$Age_status[annFilt$Age >= medAge] <- "Old"

# covs <- c("Age", "Stage", "MSI_TCGAbiolink_annot", "gender", "CMS")

annFilt <- annFilt[complete.cases(annFilt$Age), ]
annFilt <- annFilt[complete.cases(annFilt[, timeCol]), ]
annFilt$MSI_TCGAbiolink_annot[annFilt$MSI_TCGAbiolink_annot == "Indeterminate"] <- NA

```



## Lasso for Cox to select covariates
In order to decide which of the clinical factors to include, we perform lasso on the Cox models. We then use the coef of the lambda.min to decide which ones to include or exclude from the model. Based on the results below, we decide include all 4 main variables: MSI, CMS, Age and Stage, as they all had non-zero lambda.min.
```{r}
library(tidyverse)
library(broom)
library(glmnet)

set.seed(20201214)

currentAnnot_ruvSel <-
  currentAnnot_ruv[! currentAnnot_ruv$shortLetterCode  %in%  "NT" &
                   ! duplicated(currentAnnot_ruv$Sample.ID), c(
    "MSI_TCGAbiolink_annot",
    "CMS",
    "Age",
    "Stage",
    "OS.time",
    "OS"
  )]


currentAnnot_ruvSel$MSI_TCGAbiolink_annot[currentAnnot_ruvSel$MSI_TCGAbiolink_annot == "Indeterminate"] <- NA

currentAnnot_ruvSel <- currentAnnot_ruvSel[complete.cases(currentAnnot_ruvSel) &
currentAnnot_ruvSel$OS.time > 0,]


pred <- currentAnnot_ruvSel[, 
                          ! colnames(currentAnnot_ruvSel)  %in% c(timeCol, eventCol)]

x <- model.matrix(~ MSI_TCGAbiolink_annot + CMS + Age + Stage, pred)


y <- as.matrix(currentAnnot_ruvSel[, c(timeCol, eventCol)])
colnames(y) <- c("time", "status")

fit <- glmnet(
  x = x, 
  y = y, 
  family = "cox",
  alpha = 1)


plot(fit, label = T)
cv.fit <- cv.glmnet(x, y, family = "cox", alpha = 1)
plot(cv.fit)


coef(cv.fit, s = "lambda.min")


coxph(Surv(as.numeric(currentAnnot_ruvSel[, timeCol]), as.numeric(currentAnnot_ruvSel[, eventCol])) ~
        Age + Stage + MSI_TCGAbiolink_annot + CMS,
      data = currentAnnot_ruvSel)

```

```{r}
covarColumns <- c("Age", "Stage", "CMS", "MSI_TCGAbiolink_annot")
```


## Generate different format of the data

### Wide, 2/3 group scores/gene
```{r}

scoreColumns <- which(colnames(annFilt) %in% scoreNames)

wide2 <- data.frame(
  ## keep annotations and stage and age
  annFilt[, c(1:151)],
  ## add two group scores and genes
  as.data.frame(sapply(c(scoreNames), function(x) {
  # as.data.frame(sapply(c(scoreNames, "CD3", "CD8"), function(x) {
  case_when(
    annFilt[, x] >= median(annFilt[, x], na.rm = T) ~ "High",
    annFilt[, x] < median(annFilt[, x], na.rm = T) ~ "Low"
  )
}), check.names = F)
, check.names = F)


wide3 <- data.frame(## keep annotations and stage and age
  annFilt[, c(1:151)],
  ## add two group scores and genes
  as.data.frame(sapply(c(scoreNames), function(x) {
  # as.data.frame(sapply(c(scoreNames, "CD3", "CD8"), function(x) {
    case_when(
      annFilt[, x] >= quantile(annFilt[, x], probs = 0.65) ~ "High",
      annFilt[, x] <= quantile(annFilt[, x], probs = 0.35) ~ "Low",
      
      annFilt[, x] > quantile(annFilt[, x], probs = 0.35) &
        annFilt[, x] < quantile(annFilt[, x], probs = 0.65)  ~ "Intermediate"
    )
  }), check.names = F)
, check.names = F)
```

### Long 2/3 groups score/gene
```{r}

scoreAnnot <- pivot_longer(annFilt, 
                           # cols = scoreColumns[1]:scoreColumns[length(scoreColumns)], 
                           cols = scoreColumns[1]:ncol(annFilt), 
                           values_to = "Score",
                           names_to = "Signature") %>% 
  data.frame()


scoreAnnot <- scoreAnnot %>%
  data.frame() %>%
  group_by(Signature) %>%
  # mutate(MedianScore = median(TotalScore)) %>%
  mutate(
    MedianScore = median(Score),
    Quantile_low = quantile(Score, probs = 0.35),
    Quantile_High = quantile(Score, probs = 0.65),
    Score_2status = case_when(
      Score >= MedianScore ~ "High score",
      Score < MedianScore ~ "Low score"
    ),
    Score_3status = case_when(
      Score >= Quantile_High ~ "High score",
      Score <= Quantile_low ~ "Low score",
      Score < Quantile_High &
        Score > Quantile_low ~ "Intermediate score"
    )
  ) %>%
  data.frame()


# saveRDS(scoreAnnot, paste0(outPath, "TCGA_ScoreAnnot_OS.RDS"))
```


### OS: Score + covariates
We use our custom function (coxph_multitest) for performing coxph test on several signatures at the same time. We perform the analysis twice, once by grouping samples into two groups based on Median scores, and once by grouping them into 3 groups based on the top and bottom 33%-tile. 

None of the Res_Bulk/Exh_Bulk signatures alone are significantly associated with OS (after taking into account the 4 covariates).  

* Significant signature scores associated with OS when considering 2 groups:  WNT and TGFb signalling
* Significant signature scores associated with OS when considering 3 groups: Antigen presentation, Glycolysis, and WNT


```{r}

cox_OS_Score_2groups_AgeStage <-
  coxph_multitest(
    data = scoreAnnot,
    variableNameCol = "Signature",
    variableCol = "Score_2status",
    timeCol =timeCol,
    eventCol = eventCol,
    nStrata = 2,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )

cox_OS_Score_2groups_AgeStage_sig <- cox_OS_Score_2groups_AgeStage %>% filter(`Pr(>|z|)` < 0.05) %>% 
  data.frame(check.names = F)

cox_OS_Score_2groups_AgeStage_sig

cox_OS_Score_3groups_AgeStage <-
  coxph_multitest(
    data = scoreAnnot,
    variableNameCol = "Signature",
    variableCol = "Score_3status",
    timeCol = timeCol,
    eventCol = eventCol,
    nStrata = 3,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )

cox_OS_Score_3groups_AgeStage_sig <- cox_OS_Score_3groups_AgeStage %>% filter(`Pr(>|z|)` < 0.05) %>% 
  data.frame(check.names = F)

cox_OS_Score_3groups_AgeStage_sig

```


## Data preparation for: Score Pairs + covariates
Here, we examine if stratifying samples based on any two signature scores are associated with survival outcome (by considering the 4 covariates). Before that we need to prepare the data by adding new columns of score pairs. We make score pairs by combining Exh or Res signatures with other signatures from the literature (including some cancer related signatures), as well as by combining Exh and Res signatures together...
```{r}

trmSigs <- c(
  "CD8_Res_Bulk",
  "CD4_Res_Bulk",
  "NK_Res_Bulk",
  "CD8NK_Res_Bulk"
  )



exhSigs <- c(
  "CD8_Exh_Bulk",
  "CD4_Exh_Bulk",
  "NK_Exh_Bulk",
  "CD8NK_Exh_Bulk"
  )


canSigs <-
  c(
    "OXPHOS",
    "Peroxisome",
    "Glycolysis",
    "ReactiveOx",
    "Hypoxia",
    
    "DNA_Repair",
    "Antigen_Presentation",
    
    "HPX_EGF_EMT",
    "TGFbEMT",
    "EMT",
    "Mes_Thiery",
    "Epi_Thiery",
    
    "IL6_JAK_STAT3",
    "TGFb_Signaling", 
    "TP53_signaling",
    "WNT_signaling",
    "KRAS_signaling"
  )


exhTGFbCan <- c(exhSigs, canSigs)
trmTGFbCan <- c(trmSigs, canSigs)


wide2Comb <- wide2

for(s in trmSigs){
  for(e in exhTGFbCan){
    currentColumn <- paste(s, e, sep = "--")
    wide2Comb[, currentColumn] <- paste(wide2Comb[, s], s , "&",
                                      wide2Comb[, e], e)
  }
} 
  
for(s in exhSigs){
  for(e in trmTGFbCan){
    currentColumn <- paste(s, e, sep = "--")
    wide2Comb[, currentColumn] <- paste(wide2Comb[, s], s , "&",
                                      wide2Comb[, e], e)
  }
}  




wide2Comb[, "CD8_Res_Bulk--CD4_Res_Bulk"] <-
  paste(wide2Comb[, "CD8_Res_Bulk"],
        "CD8_Res_Bulk" ,
        "&",
        wide2Comb[, "CD4_Res_Bulk"],
        "CD4_Res_Bulk")
 
wide2Comb[, "CD8_Res_Bulk--NK_Res_Bulk"] <-
  paste(wide2Comb[, "CD8_Res_Bulk"],
        "CD8_Res_Bulk" ,
        "&",
        wide2Comb[, "NK_Res_Bulk"],
        "NK_Res_Bulk")
 
wide2Comb[, "CD4_Res_Bulk--NK_Res_Bulk"] <-
  paste(wide2Comb[, "CD4_Res_Bulk"],
        "CD4_Res_Bulk" ,
        "&",
        wide2Comb[, "NK_Res_Bulk"],
        "NK_Res_Bulk")

 
wide2Comb[, "CD8_Exh_Bulk--CD4_Exh_Bulk"] <-
  paste(wide2Comb[, "CD8_Exh_Bulk"],
        "CD8_Exh_Bulk" ,
        "&",
        wide2Comb[, "CD4_Exh_Bulk"],
        "CD4_Exh_Bulk")
 
wide2Comb[, "CD8_Exh_Bulk--NK_Exh_Bulk"] <-
  paste(wide2Comb[, "CD8_Exh_Bulk"],
        "CD8_Exh_Bulk" ,
        "&",
        wide2Comb[, "NK_Exh_Bulk"],
        "NK_Exh_Bulk")
 
wide2Comb[, "CD4_Exh_Bulk--NK_Exh_Bulk"] <-
  paste(wide2Comb[, "CD4_Exh_Bulk"],
        "CD4_Exh_Bulk" ,
        "&",
        wide2Comb[, "NK_Exh_Bulk"],
        "NK_Exh_Bulk")


```



```{r}
wide2CombLong <- wide2Comb %>%
  pivot_longer(
    .,
    cols = 184:ncol(wide2Comb),
    values_to = "Comb_2status",
    names_to = "Comb_Name"
  ) %>%
  data.frame()



wide2CombLong$OS.time <- wide2CombLong$OS.time/30
# wide2CombLong$PFI.time <- wide2CombLong$PFI.time/30

saveRDS(wide2CombLong, paste0(outPath, "TCGA_Survival_OS_ScoreExpr_wide_Str.RDS")) # new version
# 
# wide2CombLong <- readRDS(paste0(outPath, "TCGA_Survival_OS_ScoreExpr_wide_Str.RDS"))

```


## Pairwise comparisons with covariates
We peform Cox models with covariates for all the pairwise comparisons between quadrants of the score landscape plots for each score pair.
```{r}
# covarColumns <- c("Age", "Stage", "CMS", "MSI_TCGAbiolink_annot")

wide2CombLong$Sig1 <- sapply(wide2CombLong$Comb_Name, function(x){
  unlist(strsplit(x, "--"))[1]
})

wide2CombLong$Sig2 <- sapply(wide2CombLong$Comb_Name, function(x){
  unlist(strsplit(x, "--"))[2]
})


cox_OS_2Comb_Extremes6 <- data.frame(matrix(ncol = 17))
colnames(cox_OS_2Comb_Extremes6) <- c(
  "variable",
  "coef",
  "exp(coef)",
  "se(coef)",
  "z",
  "Pr(>|z|)",
  "exp(-coef)",
  "lower .95",
  "upper .95",
  "C",
  "se(C)",
  "test",
  "df",
  "pvalue",
  "formula",
  "VariableName", 
  "Comparison"
)

for(i in unique(wide2CombLong$Comb_Name)) {
  wide2CombLongSel <- wide2CombLong[wide2CombLong$Comb_Name == i, ]
  combns <- combn(unique(wide2CombLongSel$Comb_2status), 2)
  
  for (j in 1:ncol(combns)) {
    wide2CombLongSel2 <-
      wide2CombLongSel[wide2CombLongSel$Comb_2status %in% combns[, j], ]
    
    cur_cox_OS_2Comb_Extremes6 <-
      coxph_multitest(
        data = wide2CombLongSel2,
        variableNameCol = "Comb_Name",
        variableCol = "Comb_2status",
        timeCol = "OS.time",
        eventCol = "OS",
        nStrata = 2,
        returnCovarStat = F,
        covarCol = covarColumns,
        nCores = 10
      )
    
    cur_cox_OS_2Comb_Extremes6$Comparison <- paste(combns[1, j],
                                                   combns[2, j], sep = " vs ")
    
    cox_OS_2Comb_Extremes6 <-
      rbind(cox_OS_2Comb_Extremes6, cur_cox_OS_2Comb_Extremes6)
  }
  
}

## remove the first row of NA:
cox_OS_2Comb_Extremes6 <- cox_OS_2Comb_Extremes6[complete.cases(cox_OS_2Comb_Extremes6$variable), ]
## 1320   17 -- 220 pairs

  
cox_OS_2Comb_Extremes6_sig <-
  cox_OS_2Comb_Extremes6 %>% filter(`Pr(>|z|)` < 0.05) %>%
  data.frame(check.names = F) 
  


cox_OS_2Comb_Extremes6_sig$Group1 <- sapply(
  cox_OS_2Comb_Extremes6_sig$Comparison,
  function(x) unlist(strsplit(x, " vs "))[1])

cox_OS_2Comb_Extremes6_sig$Group2 <- sapply(
  cox_OS_2Comb_Extremes6_sig$Comparison,
  function(x) unlist(strsplit(x, " vs "))[2])
       

## add a column for the contrast
for(i in 1:nrow(cox_OS_2Comb_Extremes6_sig)) {
  curVariable <- cox_OS_2Comb_Extremes6_sig$variable[i]
  curGroup1 <- cox_OS_2Comb_Extremes6_sig$Group1[i]
  curGroup2 <- cox_OS_2Comb_Extremes6_sig$Group2[i]
  
  if (curVariable == curGroup1) {
    cox_OS_2Comb_Extremes6_sig$Contrast[i] <-
      paste0(curVariable, " - ", curGroup2)
  } else if (curVariable == curGroup2) {
    cox_OS_2Comb_Extremes6_sig$Contrast[i] <-
      paste0(curVariable, " - ", curGroup1)
  }
}  


write.csv(cox_OS_2Comb_Extremes6_sig, 
          paste0(outPath, "TCGA_Cox_OS_ExtremeScorePairs_significant_Str_pairwise6.csv"), 
          row.names = F)
```

Generate survival curves for teh significant results; these include Supp. Figure S21. 
```{r}

cox_OS_2Comb_Extremes6_sig$Comparison <- gsub("High", "H", cox_OS_2Comb_Extremes6_sig$Comparison)
cox_OS_2Comb_Extremes6_sig$Comparison <- gsub("Low", "L", cox_OS_2Comb_Extremes6_sig$Comparison)

cox_OS_2Comb_Extremes6_sig$Contrast <- gsub("High", "H", cox_OS_2Comb_Extremes6_sig$Contrast)
cox_OS_2Comb_Extremes6_sig$Contrast <- gsub("Low", "L", cox_OS_2Comb_Extremes6_sig$Contrast)

pdf(
  paste0(figPath, "OS_TCGA_ExtremeScorePairs_Cox_Str_pairwise.pdf"),
  height = 7,
  width = 8
)

for (cc in unique(cox_OS_2Comb_Extremes6_sig$VariableName)) {
  
  currentCox <- cox_OS_2Comb_Extremes6_sig[cox_OS_2Comb_Extremes6_sig$VariableName == cc, ]
  
  annot <-
    wide2CombLong[wide2CombLong$Comb_Name == cc, ]
  
  ## add p-vals
  tt <- data.frame(table(annot[, "Comb_2status"]))
  tt$Var1 <- as.character(tt$Var1)
  tt$Freq <- as.character(tt$Freq)
  
  
  for (i in 1:nrow(tt)) {
    annot$Comb_2status_n[annot[, "Comb_2status"] == tt$Var1[i]] <-
      paste0(tt$Var1[i], " (", tt$Freq[i], ")")
  }
  
  annot <- annot[, c("Comb_2status_n", timeCol, eventCol)]
  
  
  annot[, timeCol] <- as.numeric(annot[, timeCol])
  annot[, eventCol] <- as.numeric(annot[, eventCol])
  
  fitValues <- survfit(Surv(time = annot[, timeCol],
                            event = annot[, eventCol]) ~
                         annot$Comb_2status_n)
  
  
 signifCompr <- currentCox$Contrast
  
  print(survminer::ggsurvplot (
    fitValues,
    data = annot,
    fun = "pct",
    pval = T,
    conf.int = F,
    palette = cols,
    xlab = "Time",
    legend.title = "",
    title = "TCGA",
    subtitle = paste0("Significant contrasts:\n ", paste(signifCompr, collapse = "\n")), 
    legend = c(.4, .2),
    font.x = 20,
    font.y = 20,
    font.tickslab = 18,
    font.main = 20,
    font.submain = c(12, "italic"),
    font.legend = 11

  ))


}
dev.off()


```





# PFI 

```{r}
library(survival)
timeCol = "PFI.time"
eventCol = "PFI"
sn <- "PFI"

annFilt <- currentAnnot_ruv[currentAnnot_ruv$shortLetterCode != "NT", ]

medAge <- median(as.numeric(annFilt$Age), na.rm = T)

annFilt <- annFilt[complete.cases(annFilt$Age), ]
annFilt <- annFilt[complete.cases(annFilt[, timeCol]), ]

annFilt$Age_status <- NA
annFilt$Age_status[annFilt$Age < medAge] <- "Young"
annFilt$Age_status[annFilt$Age >= medAge] <- "Old"

annFilt$MSI_TCGAbiolink_annot[annFilt$MSI_TCGAbiolink_annot == "Indeterminate"] <- NA

```

## Lasso for Cox to select covariates
In order to decide which of the clinical factors to include, we need to perform lasso on the Cox models. We then use the coef of the lambda.min to decide which ones to include or exclude from the model. Based on the results below, we need to include all 4 variables as they all have non-zero coefs.
```{r}
library(tidyverse)
library(broom)
library(glmnet)

set.seed(20201214)

currentAnnot_ruvSel <-
  currentAnnot_ruv[! currentAnnot_ruv$shortLetterCode  %in%  "NT" &
                   ! duplicated(currentAnnot_ruv$Sample.ID), c(
    "MSI_TCGAbiolink_annot",
    "CMS",
    "Age",
    "Stage",
    timeCol,
    eventCol
  )]

currentAnnot_ruvSel$MSI_TCGAbiolink_annot[currentAnnot_ruvSel$MSI_TCGAbiolink_annot == "Indeterminate"] <- NA

currentAnnot_ruvSel <- currentAnnot_ruvSel[complete.cases(currentAnnot_ruvSel) &
currentAnnot_ruvSel[, timeCol] > 0,]

pred <- currentAnnot_ruvSel[, 
                          ! colnames(currentAnnot_ruvSel)  %in% c(timeCol, eventCol)]

x <- model.matrix(~ MSI_TCGAbiolink_annot + CMS + Age + Stage, pred)


y <- as.matrix(currentAnnot_ruvSel[, c(timeCol, eventCol)])
colnames(y) <- c("time", "status")

fit <- glmnet(
  x = x, 
  y = y, 
  family = "cox",
  alpha = 1)

plot(fit, label = T)
cv.fit <- cv.glmnet(x, y, family = "cox", alpha = 1)
plot(cv.fit)


coef(cv.fit, s = "lambda.min")


coxph(Surv(as.numeric(currentAnnot_ruvSel[, timeCol]), as.numeric(currentAnnot_ruvSel[, eventCol])) ~
        Age + Stage + MSI_TCGAbiolink_annot + CMS,
      data = currentAnnot_ruvSel)

```

```{r}
covarColumns <- c("Age", "Stage", "CMS", "MSI_TCGAbiolink_annot")
```



## Generate different formats of the data

### Wide, 2/3 group scores/gene
```{r}

scoreColumns <- which(colnames(annFilt) %in% scoreNames)

wide2 <- data.frame(
  ## keep annotations and stage and age
  annFilt[, c(1:151)],
  ## add two group scores and genes
  as.data.frame(sapply(c(scoreNames), function(x) {
  case_when(
    annFilt[, x] >= median(annFilt[, x], na.rm = T) ~ "High",
    annFilt[, x] < median(annFilt[, x], na.rm = T) ~ "Low"
  )
}), check.names = F)
, check.names = F)


wide3 <- data.frame(## keep annotations and stage and age
  annFilt[, c(1:151)],
  ## add two group scores and genes
  as.data.frame(sapply(c(scoreNames), function(x) {
    case_when(
      annFilt[, x] >= quantile(annFilt[, x], probs = 0.65) ~ "High",
      annFilt[, x] <= quantile(annFilt[, x], probs = 0.35) ~ "Low",
      
      annFilt[, x] > quantile(annFilt[, x], probs = 0.35) &
        annFilt[, x] < quantile(annFilt[, x], probs = 0.65)  ~ "Intermediate"
    )
  }), check.names = F)
, check.names = F)
```

### Long 2/3 groups score/gene
```{r}

scoreAnnot <- pivot_longer(annFilt, 
                           cols = scoreColumns[1]:scoreColumns[length(scoreColumns)], 
                           values_to = "Score",
                           names_to = "Signature") %>% 
  data.frame()


scoreAnnot <- scoreAnnot %>%
  data.frame() %>%
  group_by(Signature) %>%
  # mutate(MedianScore = median(TotalScore)) %>%
  mutate(
    MedianScore = median(Score),
    Quantile_low = quantile(Score, probs = 0.35),
    Quantile_High = quantile(Score, probs = 0.65),
    Score_2status = case_when(
      Score >= MedianScore ~ "High score",
      Score < MedianScore ~ "Low score"
    ),
    Score_3status = case_when(
      Score >= Quantile_High ~ "High score",
      Score <= Quantile_low ~ "Low score",
      Score < Quantile_High &
        Score > Quantile_low ~ "Intermediate score"
    )
  ) %>%
  data.frame()

```


### PFI: Score + covariates
We use our custom function (coxph_multitest) for performing coxph test on several signatures at the same time. We perform the analysis twice, once by grouping samples into two group based on Median scores, and once by grouping them into 3 groups based on the top and bottom 35%-tile. 

* Significant signature scores associated with PFI when considering 2 groups: TGFb_Signaling, NK_Res_Bulk.
* Significant signature scores associated with PFI when considering 3 groups: CD8_Res_Bulk
```{r}
scoreAnnot$PFI.time <- scoreAnnot$PFI.time/30
```

```{r}

cox_PFI_Score_2groups <-
  coxph_multitest(
    data = scoreAnnot,
    variableNameCol = "Signature",
    variableCol = "Score_2status",
    timeCol = timeCol,
    eventCol = eventCol,
    nStrata = 2,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )

cox_PFI_Score_2groups_sig <- cox_PFI_Score_2groups %>% filter(`Pr(>|z|)` < 0.05) %>% 
  data.frame(check.names = F)

cox_PFI_Score_2groups_sig$VariableName

# write.csv(
#   cox_PFI_Score_2groups,
#   paste0(outPath, "TCGA_COAD_RUV_Cox_PFI_Score_2groups_AllStat.csv"),
#   row.names = F
# )


cox_PFI_Score_3groups <-
  coxph_multitest(
    data = scoreAnnot,
    variableNameCol = "Signature",
    variableCol = "Score_3status",
    timeCol = timeCol,
    eventCol = eventCol,
    nStrata = 3,
    returnCovarStat = F,
    covarCol = covarColumns,
    nCores = 10
  )

cox_PFI_Score_3groups_sig <- cox_PFI_Score_3groups %>% filter(`Pr(>|z|)` < 0.05) %>% 
  data.frame(check.names = F)

cox_PFI_Score_3groups_sig

# write.csv(
#   cox_PFI_Score_3groups,
#   paste0(outPath, "TCGA_COAD_RUV_Cox_PFI_Score_3groups_AllStat.csv"),
#   row.names = F
# )
```


```{r}
annFilt$PFI.time <- annFilt$PFI.time/30
```


```{r}

pdf(
  paste0(figPath, "PFI_TCGA_Score2groups_Cox.pdf"),
  height = 4,
  width = 3.5
)

for (s in unique(cox_PFI_Score_2groups_sig$VariableName)) {
  print(
    survival_plot(
      data =
        ruvTCGA_tum[, rownames(annFilt)],
      # stratify = "expr",
      stratify = "score",
      annot = annFilt,
      scoreCol =  s,
      gene = NULL,
      covariate = NULL,
      isCategoricalCov = TRUE,
      timeCol = paste0(sn, ".time"),
      eventCol = sn,
      nGroup = 2,
      confInt = F,
      ylabel = paste0(sn),
      cols =
        rev(brewer.pal(10, "Paired"))
    )
  )
}

dev.off()
```

Data preparation for PFI: Score Pairs + covariates
```{r}

trmSigs <- c(
  "CD8_Res_Bulk",
  "CD4_Res_Bulk",
  "NK_Res_Bulk",
  "CD8NK_Res_Bulk"
  )


exhSigs <- c(
  "CD8_Exh_Bulk",
  "CD4_Exh_Bulk",
  "NK_Exh_Bulk",
  "CD8NK_Exh_Bulk"
  )

canSigs <-
  c(
    "OXPHOS",
    "Peroxisome",
    "Glycolysis",
    "ReactiveOx",
    "Hypoxia",
    
    "DNA_Repair",
    "Antigen_Presentation",
    
    "HPX_EGF_EMT",
    "TGFbEMT",
    "EMT",
    "Mes_Thiery",
    "Epi_Thiery",
    
    "IL6_JAK_STAT3",
    "TGFb_Signaling", 
    "TP53_signaling",
    "WNT_signaling",
    "KRAS_signaling"
  )


exhTGFbCan <- c(exhSigs, canSigs)
trmTGFbCan <- c(trmSigs, canSigs)


wide2Comb <- wide2

for(s in trmSigs){
  for(e in exhTGFbCan){
    currentColumn <- paste(s, e, sep = "--")
    wide2Comb[, currentColumn] <- paste(wide2Comb[, s], s , "&",
                                      wide2Comb[, e], e)
  }
} 
  
for(s in exhSigs){
  for(e in trmTGFbCan){
    currentColumn <- paste(s, e, sep = "--")
    wide2Comb[, currentColumn] <- paste(wide2Comb[, s], s , "&",
                                      wide2Comb[, e], e)
  }
}  



wide2Comb[, "CD8_Res_Bulk--CD4_Res_Bulk"] <-
  paste(wide2Comb[, "CD8_Res_Bulk"],
        "CD8_Res_Bulk" ,
        "&",
        wide2Comb[, "CD4_Res_Bulk"],
        "CD4_Res_Bulk")
 
wide2Comb[, "CD8_Res_Bulk--NK_Res_Bulk"] <-
  paste(wide2Comb[, "CD8_Res_Bulk"],
        "CD8_Res_Bulk" ,
        "&",
        wide2Comb[, "NK_Res_Bulk"],
        "NK_Res_Bulk")
 
wide2Comb[, "CD4_Res_Bulk--NK_Res_Bulk"] <-
  paste(wide2Comb[, "CD4_Res_Bulk"],
        "CD4_Res_Bulk" ,
        "&",
        wide2Comb[, "NK_Res_Bulk"],
        "NK_Res_Bulk")

 
wide2Comb[, "CD8_Exh_Bulk--CD4_Exh_Bulk"] <-
  paste(wide2Comb[, "CD8_Exh_Bulk"],
        "CD8_Exh_Bulk" ,
        "&",
        wide2Comb[, "CD4_Exh_Bulk"],
        "CD4_Exh_Bulk")
 
wide2Comb[, "CD8_Exh_Bulk--NK_Exh_Bulk"] <-
  paste(wide2Comb[, "CD8_Exh_Bulk"],
        "CD8_Exh_Bulk" ,
        "&",
        wide2Comb[, "NK_Exh_Bulk"],
        "NK_Exh_Bulk")
 
wide2Comb[, "CD4_Exh_Bulk--NK_Exh_Bulk"] <-
  paste(wide2Comb[, "CD4_Exh_Bulk"],
        "CD4_Exh_Bulk" ,
        "&",
        wide2Comb[, "NK_Exh_Bulk"],
        "NK_Exh_Bulk")

 

wide2CombLong <- wide2Comb %>%
  pivot_longer(
    .,
    # cols = 190:ncol(wide2Comb),
    cols = 184:ncol(wide2Comb),
    values_to = "Comb_2status",
    names_to = "Comb_Name"
  ) %>%
  data.frame()
  

saveRDS(wide2CombLong, paste0(outPath, "TCGA_Survival_PFI_ScoreExpr_wide_Str.RDS"))

# wide2CombLong <- readRDS(paste0(outPath, "TCGA_Survival_PFI_ScoreExpr_wide_Str.RDS"))
```

## Pairwise comparisons with covariates
We peform Cox models with covariates for all the pairwise comparisons between quadrants of the score landscape plots for each score pair.
```{r}

wide2CombLong$Sig1 <- sapply(wide2CombLong$Comb_Name, function(x){
  unlist(strsplit(x, "--"))[1]
})

wide2CombLong$Sig2 <- sapply(wide2CombLong$Comb_Name, function(x){
  unlist(strsplit(x, "--"))[2]
})


cox_PFI_2Comb_Extremes6 <- data.frame(matrix(ncol = 17))
colnames(cox_PFI_2Comb_Extremes6) <- c(
  "variable",
  "coef",
  "exp(coef)",
  "se(coef)",
  "z",
  "Pr(>|z|)",
  "exp(-coef)",
  "lower .95",
  "upper .95",
  "C",
  "se(C)",
  "test",
  "df",
  "pvalue",
  "formula",
  "VariableName", 
  "Comparison"
)

for(i in unique(wide2CombLong$Comb_Name)) {
  wide2CombLongSel <- wide2CombLong[wide2CombLong$Comb_Name == i, ]
  combns <- combn(unique(wide2CombLongSel$Comb_2status), 2)
  
  for (j in 1:ncol(combns)) {
    wide2CombLongSel2 <-
      wide2CombLongSel[wide2CombLongSel$Comb_2status %in% combns[, j], ]
    
    cur_cox_PFI_2Comb_Extremes6 <-
      coxph_multitest(
        data = wide2CombLongSel2,
        variableNameCol = "Comb_Name",
        variableCol = "Comb_2status",
        timeCol = timeCol,
        eventCol = eventCol,
        nStrata = 2,
        returnCovarStat = F,
        covarCol = covarColumns,
        nCores = 10
      )
    
    cur_cox_PFI_2Comb_Extremes6$Comparison <- paste(combns[1, j],
                                                   combns[2, j], sep = " vs ")
    
    cox_PFI_2Comb_Extremes6 <-
      rbind(cox_PFI_2Comb_Extremes6, cur_cox_PFI_2Comb_Extremes6)
  }
  
}

## remove the first row of NA:
cox_PFI_2Comb_Extremes6 <- cox_PFI_2Comb_Extremes6[complete.cases(cox_PFI_2Comb_Extremes6$variable), ]
## 1320   17 -- 220 pairs

  
cox_PFI_2Comb_Extremes6_sig <-
  cox_PFI_2Comb_Extremes6 %>% filter(`Pr(>|z|)` < 0.05) %>%
  data.frame(check.names = F) 
  


cox_PFI_2Comb_Extremes6_sig$Group1 <- sapply(
  cox_PFI_2Comb_Extremes6_sig$Comparison,
  function(x) unlist(strsplit(x, " vs "))[1])

cox_PFI_2Comb_Extremes6_sig$Group2 <- sapply(
  cox_PFI_2Comb_Extremes6_sig$Comparison,
  function(x) unlist(strsplit(x, " vs "))[2])
       

## add a column for the contrast
for(i in 1:nrow(cox_PFI_2Comb_Extremes6_sig)) {
  curVariable <- cox_PFI_2Comb_Extremes6_sig$variable[i]
  curGroup1 <- cox_PFI_2Comb_Extremes6_sig$Group1[i]
  curGroup2 <- cox_PFI_2Comb_Extremes6_sig$Group2[i]
  
  if (curVariable == curGroup1) {
    cox_PFI_2Comb_Extremes6_sig$Contrast[i] <-
      paste0(curVariable, " - ", curGroup2)
  } else if (curVariable == curGroup2) {
    cox_PFI_2Comb_Extremes6_sig$Contrast[i] <-
      paste0(curVariable, " - ", curGroup1)
  }
}  

write.csv(cox_PFI_2Comb_Extremes6_sig, 
          paste0(outPath, "TCGA_Cox_PFI_ExtremeScorePairs_significant_Str_pairwise6.csv"), 
          row.names = F)
```



```{r}
# cc <- "CD8NK_Exh_Bulk--NK_Res_Bulk"
# 
# currentCox <- cox_PFI_2Comb_Extremes6_sig[
#   cox_PFI_2Comb_Extremes6_sig$VariableName == cc , ]
# 
# annot <-
#   wide2CombLong[wide2CombLong$Comb_Name == cc &
#                 wide2CombLong$Comb_2status %in% c(
#                   "High CD8NK_Exh_Bulk & Low NK_Res_Bulk", "Low CD8NK_Exh_Bulk & High NK_Res_Bulk"), ]
#  
#  
# table(annot$Comb_2status, annot$OS) 
# table(annot$Comb_2status, annot$MSI_TCGAbiolink_annot)
# table(annot$Comb_2status, annot$CMS)
# table(annot$Comb_2status, annot$Stage)
```



Survival curves for significant results.
```{r}
# wide2CombLong$PFI.time <- wide2CombLong$PFI.time/30
cox_PFI_2Comb_Extremes6_sig$Comparison <- gsub("High", "H", cox_PFI_2Comb_Extremes6_sig$Comparison)
cox_PFI_2Comb_Extremes6_sig$Comparison <- gsub("Low", "L", cox_PFI_2Comb_Extremes6_sig$Comparison)

cox_PFI_2Comb_Extremes6_sig$Contrast <- gsub("High", "H", cox_PFI_2Comb_Extremes6_sig$Contrast)
cox_PFI_2Comb_Extremes6_sig$Contrast <- gsub("Low", "L", cox_PFI_2Comb_Extremes6_sig$Contrast)

pdf(
  paste0(figPath, "PFI_TCGA_ExtremeScorePairs_Cox_Str_pairwise.pdf"),
  height = 7,
  width = 8
)

for (cc in unique(cox_PFI_2Comb_Extremes6_sig$VariableName)) {
  
  currentCox <- cox_PFI_2Comb_Extremes6_sig[cox_PFI_2Comb_Extremes6_sig$VariableName == cc, ]
  annot <-
    wide2CombLong[wide2CombLong$Comb_Name == cc, ]
  
  ## add p-vals
  tt <- data.frame(table(annot[, "Comb_2status"]))
  tt$Var1 <- as.character(tt$Var1)
  tt$Freq <- as.character(tt$Freq)
  
  
  for (i in 1:nrow(tt)) {
    annot$Comb_2status_n[annot[, "Comb_2status"] == tt$Var1[i]] <-
      paste0(tt$Var1[i], " (", tt$Freq[i], ")")
  }
  
  annot <- annot[, c("Comb_2status_n", timeCol, eventCol)]
  
  
  annot[, timeCol] <- as.numeric(annot[, timeCol])
  annot[, eventCol] <- as.numeric(annot[, eventCol])
  
  fitValues <- survfit(Surv(time = annot[, timeCol],
                            event = annot[, eventCol]) ~
                         annot$Comb_2status_n)
  
  
  
 signifCompr <- currentCox$Contrast
  
  print(survminer::ggsurvplot (
    fitValues,
    data = annot,
    fun = "pct",
    pval = T,
    conf.int = F,
    palette = cols,
    xlab = "Time",
    legend.title = "",
    title = "TCGA",
    subtitle = paste0("Significant contrasts:\n ", paste(signifCompr, collapse = "\n")), 
    legend = c(.4, .2),
    font.x = 20,
    font.y = 20,
    font.tickslab = 18,
    font.main = 20,
    font.submain = c(12, "italic"),
    font.legend = 11

  ))


}
dev.off()


```




### Selected scatterplots
Generate scatterplots for selected score pairs - Figures 6A, 7A, Supp. Figure S22A.


**Scatterplot of CD8NK_Exh_Bulk vs TGFb_Signaling, coloured by CMS subtypes**
```{r, fig.height = 4.7, fig.width = 4.3}

x <- "NK_Exh_Bulk"
y <- "TGFb_Signaling"

d <- currentAnnot_ruv %>%
  mutate(MSI = MSI_TCGAbiolink_annot) %>%
  filter(! MSI  %in% "Indeterminate") %>%
  filter(! CMS  %in% "N") %>%
  mutate(medIm = median(!!sym(x)),
         medOt = median(!!sym(y)))

corVal <- round(
  cor.test(d[, x], d[, y])[[4]], 2)


palette <- cmsCol
# palette <- rev(c(brewer.pal(9, "Purples") [c(4, 6, 9)]))

pal <- list(values=palette, na.value="gray80")

print(
  d %>%
    ggplot(.,
           aes_string(x, y, color = "CMS")) +
           # aes_string(x, y, color = "MSI")) +
    geom_point(alpha = 0.8) +
    invoke(scale_colour_manual, pal) +
    geom_vline(xintercept = d$medIm) +
    geom_hline(yintercept = d$medOt) +
    scale_x_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    scale_y_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    ggtitle(paste0("TCGA (cor = ", corVal, ")")) +
    currentTheme +
    guides(color = guide_legend(nrow=2))
)

```

**Scatterplot of CD8NK_Exh_Bulk vs NK_Res_Bulk, coloured by CMS subtypes**
```{r, fig.height = 4.7, fig.width = 4.3}
x <- "CD8NK_Exh_Bulk"
y <- "NK_Res_Bulk"

d <- currentAnnot_ruv %>%
  mutate(MSI = MSI_TCGAbiolink_annot) %>%
  filter(! MSI  %in% "Indeterminate") %>%
  filter(! CMS  %in% "N") %>%
  mutate(medIm = median(!!sym(x)),
         medOt = median(!!sym(y)))

corVal <- round(
  cor.test(d[, x], d[, y])[[4]], 2)


palette <- cmsCol
# palette <- rev(c(brewer.pal(9, "Purples") [c(4, 6, 9)]))

pal <- list(values=palette, na.value="gray80")

print(
  d %>%
    ggplot(.,
           aes_string(x, y, color = "CMS")) +
           # aes_string(x, y, color = "MSI")) +
    geom_point(alpha = 0.8) +
    invoke(scale_colour_manual, pal) +
    geom_vline(xintercept = d$medIm) +
    geom_hline(yintercept = d$medOt) +
    scale_x_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    scale_y_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    ggtitle(paste0("TCGA (cor = ", corVal, ")")) +
    currentTheme +
    guides(color = guide_legend(nrow=2))
)

```


**Scatterplot of CD8NK_Exh_Bulk vs NK_Res_Bulk, coloured by CMS subtypes**
```{r, fig.height = 4.7, fig.width = 4.3}
x <- "NK_Res_Bulk"
y <- "NK_Exh_Bulk"

d <- currentAnnot_ruv %>%
  mutate(MSI = MSI_TCGAbiolink_annot) %>%
  filter(! MSI  %in% "Indeterminate") %>%
  filter(! CMS  %in% "N") %>%
  mutate(medIm = median(!!sym(x)),
         medOt = median(!!sym(y)))

corVal <- round(
  cor.test(d[, x], d[, y])[[4]], 2)


palette <- cmsCol
# palette <- rev(c(brewer.pal(9, "Purples") [c(4, 6, 9)]))

pal <- list(values=palette, na.value="gray80")

print(
  d %>%
    ggplot(.,
           aes_string(x, y, color = "CMS")) +
           # aes_string(x, y, color = "MSI")) +
    geom_point(alpha = 0.8) +
    invoke(scale_colour_manual, pal) +
    geom_vline(xintercept = d$medIm) +
    geom_hline(yintercept = d$medOt) +
    scale_x_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    scale_y_continuous(
                   breaks = equal_breaks(n = nBreak, s = scalingFactor),
                   expand = c(scalingFactor, 0)
                 ) +
    ggtitle(paste0("TCGA (cor = ", corVal, ")")) +
    currentTheme +
    guides(color = guide_legend(nrow=2))
)

```


# Mutations
The mutation file (maf) for colorectal cacner samples were downloaded using the TCGABiolink package. 
```{r}
# currentAnnot_ruv <- dList$currentAnnot_ruv

maf <- readRDS(paste0(tcgaPath, "DontPush/COAD_READ_maf.RDS"))

maf <- maf %>% 
  data.frame(check.rows = F, check.names = F)
dim(maf)
class(maf)

maf$patient <- sapply(maf$Tumor_Sample_Barcode, substr, 1, 12 )

## 394
length(intersect(maf$patient, currentAnnot_ruv$patient))


kpCols <- c(
  "patient",
    "Tumor_Sample_Barcode",
    "Hugo_Symbol",
    "Entrez_Gene_Id",
    "Variant_Classification",
    "IMPACT",
    "Variant_Type",
    "One_Consequence",
    "CANONICAL",
    "BIOTYPE"
  )

# dupGene <- mut %>%
#   group_by(Tumor_Sample_Barcode) %>%
#   mutate(dupGenes = sum(duplicated(Hugo_Symbol))) %>%
#   data.frame() 

mut <- maf[, kpCols] %>%
  ## Filter based on IMPACT
  filter(!IMPACT == "LOW" & !IMPACT == "MODIFIER") %>%
  group_by(Tumor_Sample_Barcode, Hugo_Symbol) %>%
  add_tally() %>%
  arrange(-n) %>%
  data.frame()  


mutUnique <- mut[! duplicated(mut[, c("Tumor_Sample_Barcode", "Hugo_Symbol")]) ,]
mutUnique$Variant_Types <- mutUnique$Variant_Type
mutUnique$Variant_Types[ mutUnique$n > 1] <- "MHT"

# library(tidyverse)

variants <-  mutUnique %>% 
  dplyr::select(Tumor_Sample_Barcode, Hugo_Symbol, Variant_Types) %>% 
  spread(key = Tumor_Sample_Barcode, value = Variant_Types) %>% 
  data.frame(check.names = F)

conseq <-  mutUnique %>% 
  dplyr::select(Tumor_Sample_Barcode, Hugo_Symbol, One_Consequence) %>% 
  spread(key = Tumor_Sample_Barcode, value = One_Consequence) %>% 
  data.frame(check.names = F)


gsymbols <- variants$Hugo_Symbol
variants <- as.matrix(variants[, -1])
row.names(variants) <- gsymbols

gsymbols <- conseq$Hugo_Symbol
conseq <- as.matrix(conseq[, -1])
row.names(conseq) <- gsymbols


varConsq <- matrix(paste(variants, conseq, sep = ";"), ncol = ncol(variants))
colnames(varConsq) <- colnames(conseq)
rownames(varConsq) <- rownames(conseq)

# saveRDS(varConsq, paste0(outPath, "VarConseq_TCGA_COAD.RDS"))
```

**Calculate mutational load**
```{r}
varConsqBin <- varConsq
varConsqBin[varConsqBin == "NA;NA"] <- 0
varConsqBin[varConsqBin != "0"] <- 1
varConsqBin <- apply(varConsqBin, 2, as.numeric)

row.names(varConsqBin) <- rownames(varConsq)

MutLoad <- colSums(varConsqBin)

MutLoadData <- data.frame(MutationLoad = MutLoad) %>% 
  mutate(barcode = rownames(.)) %>%
  mutate(Sample.ID = substr(barcode, 1, 16)) %>%
  data.frame()


colnames(varConsqBin) <- sapply(colnames(varConsqBin), function(x) substr(x, 1, 16))

```


**Generate long format of scoreAnnot**
```{r}
# scoreNames <- colnames(currentAnnot_ruv)[152:ncol(currentAnnot_ruv)]
scoreColumns <- which(colnames(currentAnnot_ruv) %in% scoreNames)

scoreAnnot <- pivot_longer(currentAnnot_ruv, 
                           cols = scoreColumns[1]:scoreColumns[length(scoreColumns)], 
                           values_to = "Score",
                           names_to = "Signature") %>% 
  data.frame()

```


## Build models based on mutations
To prepare the mutation data for later use, we convert the conseq data into long format and then merge it with annotation data.
```{r}
## currentAnnot does not have normal samples
## make a long format of the mut data

currentScore2 <- scoreAnnot %>% 
  dplyr::select(c(Sample.ID, Signature, Score)) %>% 
  ## Subset to interesting signatures:
  # filter(Signature %in% c(imSigs, canSigs)) %>% 
  filter(grepl("Bulk", Signature)) %>% 
  data.frame()
      

conseqLong2 <- data.frame(conseq, check.names = F) %>%
  ## save rownames as a column that has gene names
  mutate(gene_name = rownames(.)) %>%
  ## transform data into long format
  pivot_longer(.,
               cols = 1:(ncol(.) - 1),
               names_to = "Sample",
               values_to = "Mutation") %>%
    ## define dummy variable for mut
  mutate(Mut = ifelse(!is.na(Mutation), 1, 0)) %>% 
  ## add sample id to be used for merging later:
  mutate(Sample.ID = substr(Sample, 1, 16)) %>%
  ## Filter for genes with low mutations:
  group_by(gene_name) %>% 
  filter(sum(Mut) >= 10) %>% 
  ## merge with score data
  inner_join(x = ., y = currentScore2, by = "Sample.ID")


# saveRDS(conseqLong2, paste0(outPath, "TCGA_COAD_RUV_MutConseq_Long_Scores_highMutGenes_BulkSigs.RDS"))
# conseqLong2 <- readRDS(paste0(outPath, "TCGA_COAD_RUV_MutConseq_Long_Scores_highMutGenes_BulkSigs.RDS"))

```



### Linear models of Mutations 0/1 and Res/Exh scores
For each of the Res_Bulk and Exh_Bulk signatures from CD8, CD4, and NK cells, we build linera models with Scores as output and gene mutation (binary) as input. Then we perform BH correction on p-values and subset the data to significant genes.
```{r}
conseq_nested <- conseqLong2 %>% 
  group_by(gene_name, Signature) %>% 
  nest() 
  
```


```{r}
library(broom)

# scoreNames <- colnames(conseqLongFilt)[6:ncol(conseqLongFilt)]
fitModConseq <- function(df) {
  lm(formula = Score ~ Mut,
  # lm(formula = formula(paste(s, " ~ ", "Mut")),
    data = df)}

##--- the next two code commands take some time to run
conseq_model <- conseq_nested %>%
  mutate(lm_Conseq = map(data, fitModConseq))

conseq_model_glance <- conseq_model %>% 
  mutate(lmMut_glance = map(lm_Conseq, glance)) %>% 
  unnest(lmMut_glance)


##--- add adj pvals
conseq_model_adjPval <- conseq_model_glance %>% 
  mutate(adj.pval = p.adjust(p.value, method = "BH")) 

# saveRDS(conseq_model_adjPval, paste0(outPath, "TCGA_COAD_RUV_MutModel_BulkScores.RDS"))


## select specific columns and export the data frame
conseq_model_adjPvalCols <- conseq_model_adjPval %>% 
    dplyr::select(gene_name, Signature, adj.pval) %>% 
  data.frame(check.names = F)



write.table(
  conseq_model_adjPvalCols,
  paste0(outPath, "TCGA_COAD_RUV_MutModel_BulkScores_Data.txt"),
  row.names = F,
  sep = "\t"
)


sigMut <- conseq_model_adjPvalCols %>%
  filter(adj.pval < 0.01) %>%
  data.frame()

#   All_Exh_Bulk   All_Res_Bulk   CD4_Exh_Bulk 
#           1980            840           1308 
#   CD4_Res_Bulk   CD8_Exh_Bulk   CD8_Res_Bulk 
#             92           2150            928 
# CD8NK_Exh_Bulk CD8NK_Res_Bulk    NK_Exh_Bulk 
#           2744           1031           3371 
#    NK_Res_Bulk 
#            832 



# conseq_model_adjPvalCols <- read.table(
#   paste0(
#     outPath,
#     "TCGA_COAD_RUV_MutModel_BulkScores_Data.txt"
#   ),
#   # "TCGA_COAD_RUV_MutModelScores_Data.txt"),
#   header = T,
#   sep = "\t"
# )


# signifRes <- conseq_model_adjPvalCols[conseq_model_adjPvalCols$adj.pval < 0.01, ]
# write.table(
#   signifRes,
#   paste0(outPath, "TCGA_COAD_Mutations_Signatures_lm.txt"),
#   row.names = F,
#   sep = "\t"
# )
```

Subset data to genes that are significantly associated with any of the Res_Bulk and Exh_Bulk scores. This is related to Suppl Table 8.
```{r}
## filter for significant ones: 4475 genes
conseq_model_signif <- conseq_model_adjPval %>% 
  filter(adj.pval < 0.01)

# saveRDS(conseq_model_signif, paste0(outPath, "TCGA_COAD_RUV_MutModel_BulkScores_significant.RDS"))

# conseq_model_signif <- readRDS(paste0(outPath, "TCGA_COAD_RUV_MutModel_BulkScores_significant.RDS"))


conseq_model_signif <- conseq_model_signif[order(conseq_model_signif$adj.pval), ]

conseq_model_signifCols <- conseq_model_signif %>% 
  # filter(grepl("All", Signature)) %>% 
  dplyr::select(gene_name, Signature, adj.pval) %>% 
  data.frame(check.names = F)

conseq_model_signifCols$Genes <- paste0("_", conseq_model_signifCols$gene_name)

conseq_model_signifCols <- conseq_model_signifCols %>% 
  arrange(Signature, adj.pval) %>% 
  data.frame()

# write.table(
#   conseq_model_signifCols,
#   paste0(outPath, "TCGA_COAD_RUV_MutModel_BulkScores_significantData.txt"),
#   row.names = F,
#   sep = "\t"
# )
# 
# 
# conseq_model_signifCols <-
#   read.table(
#     paste0(
#       outPath,
#       "TCGA_COAD_RUV_MutModel_BulkScores_significantData.txt"
#     ),
#     header = T,
#     sep = "\t"
#   )

  # All_Exh_Bulk   All_Res_Bulk   CD4_Exh_Bulk   CD4_Res_Bulk   CD8_Exh_Bulk 
  #         1980            840           1308             92           2150 
  # CD8_Res_Bulk CD8NK_Exh_Bulk CD8NK_Res_Bulk    NK_Exh_Bulk    NK_Res_Bulk 
  #          928           2744           1031           3371            832 
```


### GO of mutations assocaited with NK_Exh_Bulk scores
For the results of the mutation analysis related to NK_Exh_Bulk signature score, we perform GO enrichment analysis. In this section, we export the Suppl Table 5, and generate Suppl Figure 9.
```{r}
library(GO.db)
library(rrvgo)
library(org.Hs.eg.db)
library(annotate)

## 740 genes
# currentSymbols <-  unique(conseq_model_signif_AllExh$gene_name[conseq_model_signif_AllExh$adj.pval < 0.001])

# 209 genes
# currentSymbols <-  unique(conseq_model_signif_AllTrm$gene_name[conseq_model_signif_AllTrm$adj.pval < 0.001])

currentSymbols <-  unique(conseq_model_signifCols$gene_name[conseq_model_signifCols$Signature == "NK_Exh_Bulk" & conseq_model_signifCols$adj.pval < 0.0001])


currentIDs <-
  mapIds(org.Hs.eg.db,
         keys = currentSymbols,
         'ENTREZID',
         'SYMBOL')

currentIDs <- currentIDs[complete.cases(currentIDs)]

goExh <- limma::goana(currentIDs, FDR = 0.01, species = "Hs")
go_analysis <- limma::topGO(goExh, ontology = "BP", number = Inf)

go_analysis <- go_analysis[go_analysis$P.DE < 0.01, ]
# go_analysis <- go_analysis[go_analysis$P.DE < 0.0001, ]
 

go_analysis <- go_analysis[go_analysis$N > 20 & go_analysis$N < 1500, ]
# bp <- names(Ontology(GOTERM))[Ontology(GOTERM) == "BP"]
# # 29211 BP terms

simMatrix <- calculateSimMatrix(rownames(go_analysis),
                                orgdb = "org.Hs.eg.db",
                                ont = "BP",
                                method = "Rel")

scores <- setNames(-log10(go_analysis$P.DE), rownames(go_analysis))

reducedTerms <- reduceSimMatrix(simMatrix,
                                scores,
                                threshold = 0.8,
                                orgdb = "org.Hs.eg.db")

write.table(
  go_analysis,
  paste0(outPath, "GO_TCGA_NK_Exh_mutSig.0001_GO.01_th.8.txt"),
  row.names = T,
  sep = "\t"
)

pdf(
  paste0(figPath, "GO_TCGA_Mut_NK_Exh_mutSig.0001_GO.01_th.8.pdf"),
  height = 8,
  width = 14
)
heatmapPlot(
  simMatrix,
  reducedTerms,
  annotateParent = TRUE,
  annotationLabel = "parentTerm",
  fontsize = 10,
  fontsize_row = 1,
  fontsize_col = 1
)
dev.off()


# pdf(
#   paste0(figPath, "GO_ScatterPlot_TreeMap_TCGA_Mut_NK_Exh_mutSig.0001_GO.01.pdf"),
#   height = 10,
#   width = 10
# )
# scatterPlot(simMatrix, reducedTerms)
# treemapPlot(reducedTerms)
# dev.off()
# rrvgo::shiny_rrvgo()
```


###  Boxplots of scores for selected genes
This reproduces Figure 5 in the paper, which includes boxplots of scores stratified by mutation status for selected genes:
"BRAF", "APC", "JAK1", "STAT1", "SPEN", "DNAH3". The code below exports several PDF files.
```{r}
selgenes <- c("BRAF", "APC", "JAK1", "STAT1", "SPEN", "DNAH3")

conseq_model_signif_ExhTrm <- conseq_model_signif %>%
  filter(!grepl("All", Signature)) %>%
  dplyr::select(gene_name, Signature, adj.pval) %>%
  data.frame(check.names = F)


selSigs <- unique(conseq_model_signif_ExhTrm$Signature)[
  order(unique(conseq_model_signif_ExhTrm$Signature))
]

mutSignif_selGenesImmune <- conseq_model_adjPval %>%
  filter(gene_name %in% selgenes &
           Signature %in% selSigs)


currentMutData <- mutSignif_selGenesImmune


currentMutData$gene_name <- as.character(currentMutData$gene_name) 

library(gridExtra)

for(i in selSigs) {
  ss <- currentMutData[currentMutData$Signature == i, ]
  
  p <- list()
  
  for (g in 1:nrow(ss)) {
    mm <- ss$lm_Conseq[[g]]
    
    p[[g]] <- augment(mm) %>%
      mutate(Mut = as.logical(Mut)) %>%
      ggplot(data = ., aes(x = Mut, y = Score, color = Mut)) +
      geom_boxplot() +
      geom_jitter(position = position_jitter(0.2), alpha = 0.4) +
      geom_signif(
        comparisons = list(c("FALSE", "TRUE")),
        map_signif_level = TRUE,
        tip_length = 0,
        vjust = 1.4,
        col = "gray40"
      ) +
      ggtitle(paste0(as.character(ss$gene_name[g]))) +
      scale_color_manual(values = brewer.pal(4, "Dark2")[c(1, 3)]) +
      scale_x_discrete(breaks = c("FALSE", "TRUE"),
                       labels = c("WT", "Mut")) +
      scale_y_continuous(
        breaks = equal_breaks(n = nBreak, s = scalingFactor),
        expand = c(scalingFactor, 0)
      ) +
      theme_bw() +
      theme(
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "none"
      )
    
  }
  names(p) <- ss$gene_name
  p <- p[selgenes]
  
  
  pdf(
    paste0(
      figPath,
      "Boxplot_TCGA_COAD_RUV_Mut_",
      i,
      "_Scores_selGenes.pdf"
    ),
    height = 2.5,
    width = 8
  )
  do.call(grid.arrange, c(p, ncol = 6))
  grid.arrange(grobs = p,
               ncol = 6
               # widths = c(1, 1, 1),
               # layout_matrix = rbind(c(1, 2, 3))
               )
               dev.off()
}

```

## Elastic Net regression
Here we perform Elastic Net Regression with NK scores as output and all the significant genes obtained above for the NK scores as well as a few clinical annotations as inputs. 
```{r}
currentAnnot_ruvSel <-
  currentAnnot_ruv[! currentAnnot_ruv$shortLetterCode == "NT" &
                   ! duplicated(currentAnnot_ruv$Sample.ID), c(
    "Sample.ID",
    "MSI_TCGAbiolink_annot",
    "CMS",
    "Stage",
    "NK_Exh_Bulk",
    "NK_Res_Bulk"
  )]

currentAnnot_ruvSel$MSI_TCGAbiolink_annot[currentAnnot_ruvSel$MSI_TCGAbiolink_annot == "Indeterminate"] <- NA

## remove samples with NA for clinical data
## 412 samples --> 351 samples
apply(currentAnnot_ruvSel, 2, function(x) sum(is.na(x)))

currentAnnot_ruvSel <- currentAnnot_ruvSel[complete.cases(currentAnnot_ruvSel), ]

## keep genes with mutations in >= 10 samples
mutPerGene <- colSums(t(varConsqBin) == 1)
kpGenes <- mutPerGene >= 10
# 7037 TRUE

gg <- names(mutPerGene[kpGenes])
varConsqBinData <-
  data.frame(t(varConsqBin)[, kpGenes],
             MutLoadData,
             check.names = F,
             check.rows = F)

## again we have gene mutated in less than 10 samples after merging the data:
varConsqBinDataClin <-
  merge(varConsqBinData,
        currentAnnot_ruvSel,
        by.x = "row.names",
        by.y = "Sample.ID")

mutPerGene <- colSums(varConsqBinDataClin[, gg])
## 3238 genes
rmGenes <- names(mutPerGene[mutPerGene < 10])

varConsqBinDataClin <- varConsqBinDataClin[,  !colnames(varConsqBinDataClin)  %in% rmGenes]
# 4772 genes --> 3238 genes

rownames(varConsqBinDataClin) <- varConsqBinDataClin$Sample.ID

saveRDS(
  varConsqBinDataClin,
  paste0(outPath, "ExasticNetData_varConsqBinDataClin_TCGA.RDS")
)

# varConsqBinDataClin <- readRDS(
#   paste0(outPath, "ExasticNetData_varConsqBinDataClin_TCGA.RDS")
# )


```

### Factors predictive of NK_Exh_Bulk scores
```{r}
## REMOVE columns we do not need:
dataGlmnet <- varConsqBinDataClin[, !colnames(varConsqBinDataClin) %in% c(
  "Row.names",
  "barcode",
  "Sample.ID",
  "MutationLoad_Groups",
  "site_of_resection_or_biopsy",
  "NK_Res_Bulk"
)]


model_formula <- as.formula("NK_Exh_Bulk ~ .")

X <- model.matrix(model_formula, 
                  data = dataGlmnet)[,
                                     -which(
  colnames(dataGlmnet) == "NK_Exh_Bulk")  ]

y <- dataGlmnet$NK_Exh_Bulk


##------ select lambdas
lambda_values <- 10^seq(-2, 10, length = 100)

cv_fit <- cv.glmnet(X, y, alpha = 0.5, lambda = lambda_values)

plot(cv_fit)
opt_lambda <- cv_fit$lambda.min
opt_lambda
##  0.0175 for Exh 


##------ I repeated with smaller lambad, and the resultant genes were very similar
lambda_values0 <- 10^seq(-2, 1, length = 100)

cv_fit0 <- cv.glmnet(X, y, alpha = 0.5, lambda = lambda_values0)

plot(cv_fit0)
opt_lambda0<- cv_fit0$lambda.min
opt_lambda0


##--------
model0 <- glmnet(X, y, alpha = 0.5, lambda = lambda_values)

# pdf(paste0(figPath, "TCGA_ElastiNet_NK_Exh_plots.pdf"), 
#     height = 5, width = 7)
plot(cv_fit)
plot(model0, xvar="lambda")
plot(model0, main="Elastic Net")
# dev.off()

##--------

model <- glmnet(X, y, alpha = 0.5, lambda = opt_lambda)

b <- as.matrix(model$beta)

b <- b[ b[,1] != 0, ]
b <- data.frame(beta = b)
b <- b[order(b, decreasing = T), , drop = F]


model0 <- glmnet(X, y, alpha = 0.5, lambda = opt_lambda0)

b0 <- as.matrix(model0$beta)

b0 <- b0[ b0[,1] != 0, ]
b0 <- data.frame(beta = b0)
b0 <- b0[order(b0, decreasing = T), , drop = F]

## 46 predictive variables for d, including two CMS3 and CMS4
## 43 for d0, and 42 are overlapping


saveRDS(model, paste0(outPath, "TCGA_Models_NK_Exh_ElasticNet.RDS"))

# model <- readRDS(paste0(outPath, "TCGA_Models_NK_Trm_ElasticNet.RDS"))

write.table(
  b,
  paste0(outPath, "TCGA_Models_NK_Exh_ElasticNet.txt"),
  row.names = T,
  sep = "\t"
)

```

### Factors predictive of NK_Res_Bulk scores
```{r}
## REMOVE columns we do not need:
dataGlmnet <- varConsqBinDataClin[, !colnames(varConsqBinDataClin) %in% c(
  "Row.names",
  "barcode",
  "Sample.ID",
  "MutationLoad_Groups",
  "site_of_resection_or_biopsy",
  "NK_Exh_Bulk"
)]

model_formula <- as.formula("NK_Res_Bulk ~ .")

X <- model.matrix(model_formula, 
                  data = dataGlmnet)[,
                                     -which(
  colnames(dataGlmnet) == "NK_Res_Bulk")  ]

y <- dataGlmnet$NK_Res_Bulk



##------ select lambdas
lambda_values <- 10^seq(-2, 10, length = 100)

cv_fit <- cv.glmnet(X, y, alpha = 0.5, lambda = lambda_values)

plot(cv_fit)
opt_lambda <- cv_fit$lambda.min
opt_lambda  ##   0.0132 for Res 0.01


##------ if repeating with small lambad, then: min.lambda is the same 
lambda_values0 <- 10^seq(-2, 1, length = 100)

cv_fit0 <- cv.glmnet(X, y, alpha = 0.5, lambda = lambda_values0)

plot(cv_fit0)
opt_lambda0<- cv_fit0$lambda.min
opt_lambda0



model0 <- glmnet(X, y, alpha = 0.5, lambda = lambda_values)

# pdf(paste0(figPath, "TCGA_ElastiNet_NK_Res_plots.pdf"), 
#     height = 5, width = 7)
plot(cv_fit)
plot(model0, xvar="lambda")
plot(model0, main="Elastic Net")
# dev.off()

##--------
model <- glmnet(X, y, alpha = 0.5, lambda = opt_lambda)

b <- as.matrix(model$beta)

b <- b[ b[,1] != 0, ]
b <- data.frame(beta = b)
b <- b[order(b, decreasing = T), , drop = F]


model0 <- glmnet(X, y, alpha = 0.5, lambda = opt_lambda0)

b0 <- as.matrix(model0$beta)

b0 <- b0[ b0[,1] != 0, ]
b0 <- data.frame(beta = b0)
b0 <- b0[order(b0, decreasing = T), , drop = F]


saveRDS(model, paste0(outPath, "TCGA_Models_NK_Res_ElasticNet.RDS"))
# 
write.table(
  b,
  paste0(outPath, "TCGA_Models_NK_Res_ElasticNet.txt"),
  row.names = T,
  sep = "\t"
)
```


```{r}
en_trm <- read.table(
  paste0(outPath, "TCGA_Models_NK_Res_ElasticNet.txt"),
  header = T,
  sep = "\t"
)
en_exh <- read.table(
  paste0(outPath, "TCGA_Models_NK_Exh_ElasticNet.txt"),
  header = T,
  sep = "\t"
)

com_EN <- intersect(row.names(en_exh), row.names(en_trm))
#  [1] "HTR5A"    "TUBGCP3"  "CMSCMS4"  "SMTN"     "BRAF"     "DCAF12L2"
#  [7] "INSM2"    "ARID2"    "ZNF543"   "RNF20"    "KIF26A"   "CPXM2"   
# [13] "APC"    

exhOnly_EN <- row.names(en_exh)[! row.names(en_exh) %in% row.names(en_trm)]
#  [1] "POLD1"   "JAK1"    "PKN3"    "PIK3R5"  "TGM6"   
#  [6] "NOVA1"   "SLC19A1" "VPS33A"  "TCHH"    "TRRAP"  
# [11] "TJP2"    "SASH1"   "DLGAP4"  "MACF1"   "`HLA-B`"
# [16] "ARID1A"  "JPH3"    "ARID1B"  "ROR2"    "PLEKHA6"
# [21] "SYNRG"   "CLCN4"   "USP5"    "EMILIN1" "DNAH3"  
# [26] "ZFHX4"   "CAMKK2"  "DNAH2"   "PLXNA1"  "MXRA5"  
# [31] "NOL4L"   "SRCIN1"  "CMSCMS3"

trmOnly_EN <- row.names(en_trm)[! row.names(en_trm) %in% row.names(en_exh)]
# [1] "HGF"       "SLC10A2"   "PAK4"      "TUBA3C"   
#  [5] "APBB1IP"   "ADGRA2"    "FRMD4A"    "SPATA31E1"
#  [9] "CYFIP2"    "SAP130"    "MROH7"     "DIAPH2"   
# [13] "MYH13"     "PCSK5"     "KCNA6"     "POLR3B"   
# [17] "MMP13"     "FAM21C"    "MST1R"     "CDON"     
# [21] "ANK3"      "NFRKB"     "TLR9"      "TGFBRAP1" 
# [25] "LAMB2"     "CADPS"     "PPARGC1B"  "SH3TC1"   
# [29] "MPDZ"      "TET1"      "KLC1"      "TMEM132D" 
# [33] "SGSM1"     "TET2"      "MYLK"      "PTK2B"    
# [37] "TFAP2D"    "ZYG11B"    "DDX54"     "ADGRG2"   
# [41] "LRP1"      "C8B"       "ZNF646"    "MYO9B"    
# [45] "GRIK3"     "NPHS1"     "NTM"       "C18orf8"  
# [49] "SHOX"      "IGSF9B"    "PXDN"      "TP53"     
# [53] "CEP350"    "EML1"      "TECPR2"    "APP"      
# [57] "OLFM1"     "SPAG17"    "OSR2"      "MYO5C"    
# [61] "DCBLD1"    "SNTG1"     "PCDHGB3"    
```

Export a table containing all the predictive variables for NK_Res_Bulk and NK_Exh_Bulk scores (Suppl Table 10). 

```{r}
enNK <-
  data.frame(
    predictors = unique(c(
      rownames(en_trm), 
      rownames(en_exh))))

enNK$Output[enNK$predictors  %in% rownames(en_trm)] <- "NK_Res"
enNK$Output[enNK$predictors  %in% rownames(en_exh)] <- "NK_Exh"
enNK$Output[enNK$predictors  %in% rownames(en_exh) &
             enNK$predictors  %in% rownames(en_trm) ] <- "Both"

enNK_beta <-
  merge(enNK,
        en_trm,
        by.x = "predictors",
        by.y = "row.names",
        all.x = T)
colnames(enNK_beta)[3] <- "beta_NK_Res"

enNK_beta <-
  merge(enNK_beta,
        en_exh,
        by.x = "predictors",
        by.y = "row.names",
        all.x = T)
colnames(enNK_beta)[4] <- "beta_NK_Exh"

enNK_beta$predictors[enNK_beta$predictors == "`HLA-B`"] <- "HLA-B"
enNK_beta$predictors[enNK_beta$predictors == "CMSCMS3"] <- "CMS3"
enNK_beta$predictors[enNK_beta$predictors == "CMSCMS4"] <- "CMS4"

write.table(
  enNK_beta,
  paste0(outPath, "TCGA_ElasticNet_NK_ResExh_beta.txt"),
  row.names = F,
  sep = "\t"
)


# enNK_beta <- read.table(paste0(outPath, "TCGA_ElasticNet_NK_ResExh_beta.txt"),
#                         header = T, sep = "\t")
```

### Boxplot of Elastic Net results
We generate boxplots of NK_Exh_Bulk and NK_Res_Bulk scores stratified by mutations status (Mut vs WT) for genes that are predictive of both signature scores (Suppl Figure S16), for genes that are predictive of only NK_Exh_Bulk scores (Suppl Figure S17), and for those that are predictive of only NK_Res_Bulk scores (Suppl Figure S18). 
```{r}
rmCols <- c(
  "Row.names",
  "MutationLoad",
  "barcode",
  "Sample.ID",
  "MSI_TCGAbiolink_annot",
  "CMS",
  "Stage"
)


dbox <- varConsqBinDataClin[, ! colnames(varConsqBinDataClin)  %in% rmCols]

dbox <- dbox[, colnames(dbox) %in% c(
  unique(enNK_beta$predictors),
  "NK_Exh_Bulk",
  "NK_Res_Bulk")]

dboxLong <- dbox %>% 
  rownames_to_column(var = "patient") %>% 
  pivot_longer(cols = 2:(ncol(dbox)-1), values_to = "Mut", names_to = "Genes") %>% 
  data.frame(check.names = F)

dboxLong$Mut[dboxLong$Mut == 1] <- "Mut"
dboxLong$Mut[dboxLong$Mut == 0] <- "WT"

dboxLong$Mut <- factor(dboxLong$Mut, levels = c("WT", "Mut"))

```


#### Genes predictive of both signature scores
```{r, fig.height = 7, fig.width = 10}
p1 <- dboxLong %>%
  filter(Genes %in% intersect(row.names(en_exh), row.names(en_trm))) %>%
  # mutate(Mut = as.logical(Mut)) %>%
  ggplot(data = ., aes(x = Mut, y = NK_Exh_Bulk, color = Mut)) +
  geom_boxplot() +
  geom_jitter(position = position_jitter(0.2), alpha = 0.4) +
  facet_wrap( ~ Genes) +
  ggpubr::geom_signif(
    comparisons = list(c("Mut", "WT")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  scale_color_manual(values = brewer.pal(4, "Dark2")[c(1, 3)]) +
  scale_x_discrete(breaks = c("FALSE", "TRUE"),
                   labels = c("WT", "Mut")) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  currentTheme +
  theme(
     axis.title.x = element_blank())


p2 <- dboxLong %>%
  filter(Genes %in% intersect(row.names(en_exh), row.names(en_trm))) %>%
  # mutate(Mut = as.logical(Mut)) %>%
  ggplot(data = ., aes(x = Mut, y = NK_Res_Bulk, color = Mut)) +
  geom_boxplot() +
  geom_jitter(position = position_jitter(0.2), alpha = 0.4) +
  facet_wrap( ~ Genes) +
  ggpubr::geom_signif(
    comparisons = list(c("Mut", "WT")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  scale_color_manual(values = brewer.pal(4, "Dark2")[c(1, 3)]) +
  scale_x_discrete(breaks = c("FALSE", "TRUE"),
                   labels = c("WT", "Mut")) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  currentTheme +
  theme(
     axis.title.x = element_blank())


library(gridExtra)

pdf(paste0(figPath,
           "Boxplot_TCGA_Mut_ElasticNet_SignifComNKResExh.pdf"),
    height = 7, width = 10
    )

grid.arrange(
  grobs = list(p1, p2),
  ncol = 2
)

dev.off()

```


#### Genes predictive of NK_Exh_Bulk only
```{r, fig.height = 9, fig.width=10}
p <- dboxLong %>%
  filter(Genes %in% 
           c(row.names(en_exh)[! row.names(en_exh) %in% row.names(en_trm)], "HLA-B")) %>%
  # mutate(Mut = as.logical(Mut)) %>%
  ggplot(data = ., aes(x = Mut, y = NK_Exh_Bulk, color = Mut)) +
  geom_boxplot() +
  geom_jitter(position = position_jitter(0.2), alpha = 0.4) +
  facet_wrap( ~ Genes, ncol = 8) +
  ggpubr::geom_signif(
    comparisons = list(c("Mut", "WT")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  scale_color_manual(values = brewer.pal(4, "Dark2")[c(1, 3)]) +
  scale_x_discrete(breaks = c("FALSE", "TRUE"),
                   labels = c("WT", "Mut")) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  currentTheme +
  theme(
     axis.title.x = element_blank())

pdf(
  paste0(figPath,
         "Boxplot_TCGA_Mut_ElasticNet_SignifOnlyNKExh.pdf"),
  height = 9,
  width = 10
)
p
dev.off()

```

#### Genes predictive of NK_Res_Bulk only
```{r}
p <- dboxLong %>%
  filter(Genes %in% 
           row.names(en_trm)[! row.names(en_trm) %in% row.names(en_exh)]) %>%
  # mutate(Mut = as.logical(Mut)) %>%
  ggplot(data = ., aes(x = Mut, y = NK_Res_Bulk, color = Mut)) +
  geom_boxplot() +
  geom_jitter(position = position_jitter(0.2), alpha = 0.4) +
  facet_wrap( ~ Genes, ncol = 9) +
  ggpubr::geom_signif(
    comparisons = list(c("Mut", "WT")),
    map_signif_level = TRUE,
    tip_length = 0,
    vjust = 1.4,
    col = "gray40"
  ) +
  scale_color_manual(values = brewer.pal(4, "Dark2")[c(1, 3)]) +
  scale_x_discrete(breaks = c("FALSE", "TRUE"),
                   labels = c("WT", "Mut")) +
  scale_y_continuous(breaks = equal_breaks(n = nBreak, s = scalingFactor),
                     expand = c(scalingFactor, 0)) +
  currentTheme +
  theme(
     axis.title.x = element_blank())

pdf(
  paste0(figPath,
         "Boxplot_TCGA_Mut_ElasticNet_SignifOnlyNKRes.pdf"),
  height = 13,
  width = 10
)
p
dev.off()
```


# Session information
Here are the list of tools and packages (along with their versions) used in this document. 
```{r}
sessionInfo()
```

<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 598px;"></div>









